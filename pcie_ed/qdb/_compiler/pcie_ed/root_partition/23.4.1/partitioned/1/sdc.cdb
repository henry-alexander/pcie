22 serialization::archive 19 0 0 0 0 5 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 0 0 11 0 0 0 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 11 pcie_ed_dut 18 intel_pcie_gts_300 5 synth 13 sm_pciess.sdc 39344 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


if [info exists ip_inst_name] {
  unset ip_inst_name
  }
set ip_inst_name [get_current_instance]
puts "PCIE SS SDC INSTANCE: $ip_inst_name"

 ## set global variables
 global ::ip_sdc_debug
 
 set ip_sdc_debug 0

 ## get current IP instance 
 if {$ip_sdc_debug == 1} {
        post_message -type info "IP SDC: $ip_inst_name"
 }


# ----------------------------------------------------------------
#
proc xcvrphy_is_node_type_refreg { node_id node_search ip_inst_name} {
#
# Description: Given a node, checks if a string is present or not
#              Removed check for ip_inst_name as it might be diff
#                                       in case of Sys PLL clock
# ----------------------------------------------------------------
 if {[regexp $node_search [get_node_info -name $node_id]] == 1} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

# ----------------------------------------------------------------
#
proc xcvrphy_is_node_type_pin { node_id node_search ip_inst_name } {
#
# Description: Given a node, tells whether or not it is a certain type or not (e.g. pin, port)
#              Also check for ip_inst_name to find the right node
#
# ----------------------------------------------------------------
   set node_type [get_node_info -type $node_id]

   if {$node_type == $node_search && [regexp [get_node_info -name $node_id] "$ip_inst_name"] == 1} {
      set result 1
   } else {
      set result 0
   }
   return $result
}

#
# ----------------------------------------------------------------
#
proc xcvrphy_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth node_search ip_inst_name} {
#
# Description: Recurses through the timing netlist starting from the given
#              node_id through edges of type edge_type to find nodes
#              satisfying match_command.
#              Recursion depth is bound to the specified depth.
#              Adds the resulting TDB node ids to the results_array.
#
# ----------------------------------------------------------------
   upvar 1 $results_array_name results

   if {$depth < 0} {
      error "Internal error: Bad timing netlist search depth"
   }
   set fanin_edges [get_node_info -${edge_type}_edges $node_id]
   set number_of_fanin_edges [llength $fanin_edges]
        #post_message -type info "number_of_fanin_edges $number_of_fanin_edges"
        for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
      set fanin_edge [lindex $fanin_edges $i]
      set fanin_id [get_edge_info -src $fanin_edge]
                #post_message -type info "fanin_id [get_node_info -name $fanin_id]"
                if {$match_command == "" || [eval $match_command $fanin_id $node_search $ip_inst_name] != 0} {
                        #post_message -type info "fanin_id [get_node_info -name $fanin_id]"
                        #post_message -type info "match"
                        set results($fanin_id) [expr {$i+1}]
      } elseif {$depth == 0} {
                        puts "no more here"
         # Max recursion depth
      } else {
                        #post_message -type info "disabled edge info : [get_edge_info -is_disabled $fanin_edge]"
                        if {[get_edge_info -is_disabled $fanin_edge]==0} {
                                xcvrphy_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}] $node_search $ip_inst_name
                        } else {
                        # no further traversal if edge is disabled
                        }
      }
   }
}


#
# ----------------------------------------------------------------
#
proc xcvrphy_get_input_clk_id { xcvr_inclk_id var_array_name ip_inst_name} {
#
# Description: calls the recursive traversing function to search for clock_edges 
#
# ----------------------------------------------------------------

   upvar 1 $var_array_name var

   array set results_array [list]

   # Find the input pin
   # Depth set to 10 to adaquately handle ref clock tree traversal
   xcvrphy_traverse_fanin_up_to_depth $xcvr_inclk_id $var(node_check_command) clock results_array $var(xcvr_inclock_search_depth) $var(node_search) $ip_inst_name
   if {[array size results_array] == 1} {
      # Fed by a dedicated input pin
                set pin_id [lindex [array names results_array] 0]
                set result $pin_id
   } else {
      post_message -type critical_warning "Could not find XCVR clock for [get_node_info -name $xcvr_inclk_id]"
      set result -1
   }

   return $result
}


# ----------------------------------------------------------------
#
proc xcvrphy_traverse_fanins { ip_inst_name dummy_sip_flop_name clk_type ip_inst_name ip_sdc_debug} {
#
# Description: Retruns source clk_ref/reg node for XCVR user clock which drives dummy flop placed in SIP
#
# ----------------------------------------------------------------

        set var(xcvr_inclock_search_depth) 3
        set var(node_check_command) xcvrphy_is_node_type_pin

        set dummy_sip_flop_node [get_nodes $ip_inst_name|*|${dummy_sip_flop_name}*|clk]

        set var(node_search) "pin"
        set dummy_flop_clock_pin [xcvrphy_get_input_clk_id $dummy_sip_flop_node var  $ip_inst_name]

        set dummy_flop_clock_pin_node [get_node_info -name $dummy_flop_clock_pin ]

        if {$ip_sdc_debug == 1} {
                if {$clk_type == "pin"} {
                        post_message -type info "IP SDC: Clock Pin source found for $dummy_sip_flop_name: $dummy_flop_clock_pin_node"
                }
        }

   if {$clk_type != "pin"} {
                set var(node_check_command) xcvrphy_is_node_type_refreg
                set var(node_search) $clk_type

                set xcvrclk_src [xcvrphy_get_input_clk_id $dummy_flop_clock_pin_node var  $ip_inst_name]
                set xcvrclk_src_node [get_node_info -name $xcvrclk_src]

                if {$ip_sdc_debug == 1} {
                        if {[regexp "ref" $clk_type] == 1} {
                                post_message -type info "IP SDC: Clock Ref source found for $dummy_sip_flop_name: $xcvrclk_src_node"
                        } else {
                                post_message -type info "IP SDC: Clock Reg source found for $dummy_sip_flop_name: $xcvrclk_src_node"
                        }
                }
        }

        if {$clk_type == "pin"} {
                return $dummy_flop_clock_pin_node
        } else {
      return $xcvrclk_src_node
        }
}


# ----------------------------------------------------------------
#
proc lookup_clock_target { lookup_string } {
#
# Description: Retruns whether lookup_string is present in target of any of already created clocks in the design
#
# ----------------------------------------------------------------
    set clocks_collection [get_clocks -nowarn]
      if {[get_collection_size $clocks_collection] > 0} {
        foreach_in_collection clock $clocks_collection {
          if { ![is_clock_defined $clock] } {
            continue
          }
          set clock_name [get_clock_info -name $clock]
          set clock_target_collection [get_clock_info -target $clock]
          if {[get_collection_size $clock_target_collection] > 0} {
            foreach_in_collection clock_target $clock_target_collection {
              set clock_target_name [get_node_info -name $clock_target]
              if {[string equal $lookup_string $clock_target_name] == 1} {
                return 1
              }
            }
          }
        }
        return 0
      } else {
      return 0
      }
}


# ----------------------------------------------------------------
#
proc lookup_clock_target_name { lookup_string } {
#
# Description: Retruns already created clock name whose target has lookup_string
#
# ----------------------------------------------------------------

   set clocks_collection [get_clocks]
   if {[get_collection_size $clocks_collection] > 0} {
     foreach_in_collection clock $clocks_collection {
       if { ![is_clock_defined $clock] } {
         continue
       }
       set clock_name [get_clock_info -name $clock]
       set clock_target_collection [get_clock_info -target $clock]
       if {[get_collection_size $clock_target_collection] > 0} {
         foreach_in_collection clock_target $clock_target_collection {
           set clock_target_name [get_node_info -name $clock_target]
           if {[string equal $lookup_string $clock_target_name] == 1} {
             return $clock_name
           }
         }
       }
     }
       return 0
   } else {
   return 0
   }
}


#
# ----------------------------------------------------------------
#
proc get_clock_source_from_node { ip_inst_name dummy_sip_flop_name } {
#
# Description: Get the clock edge info from node and eventually to get the 
#              clock source
# ----------------------------------------------------------------
   puts "Start of get_clock_source_from_node, input1 $ip_inst_name ,,, input2 $dummy_sip_flop_name"
   set dummy_sip_flop_node [get_nodes $ip_inst_name|*|${dummy_sip_flop_name}*|clk]
   query_collection [get_nodes $ip_inst_name|*|${dummy_sip_flop_name}*|clk]
   set fanin_edges [get_node_info -clock_edges $dummy_sip_flop_node]
   puts $fanin_edges
   set fanin_id [get_edge_info -src $fanin_edges]
   post_message -type info "Getting top level source clock from node $dummy_sip_flop_node => [get_node_info -name $fanin_id]"
   set fanin_id_name [get_node_info -name $fanin_id]
   return $fanin_id_name

}






# Check if port exists
proc pcie_port_existence {port_name ip_sdc_debug} {

   set port_collection [get_ports -nowarn $port_name]

   if {$ip_sdc_debug} {
        post_message -type info "Port exists for $port_name : $port_collection"
	foreach_in_collection port $port_collection {
	   set detected_port_name [get_port_info -name $port]
           post_message -type info "Ports found for $port_name : $detected_port_name"
	}
   }

   if { [get_collection_size $port_collection] > 0 } {
      return 1
   } else {
      return 0
   }
}

# Check if clock exists
proc pcie_clk_existence {clk_name ip_sdc_debug} {

   set clk_collection [get_clocks -nowarn $clk_name]

   if {$ip_sdc_debug} {
        post_message -type info "Clock exists for $clk_name : $clk_collection"
	foreach_in_collection clk $clk_collection {
	   set detected_clk_name [get_clock_info -name $clk]
           post_message -type info "Clock found for $clk_name : $detected_clk_name"
	}
   }

   if { [get_collection_size $clk_collection] > 0 } {
      return 1
   } else {
      return 0
   }
}

# Return existing clock target list
proc pcie_get_clock_target_list { ip_sdc_debug } {

   set result [list]
   set clocks_collection [get_clocks -nowarn]
   foreach_in_collection clock $clocks_collection { 
      if { ![is_clock_defined $clock] } {
         continue
      }
      set clock_name       [get_clock_info -name $clock] 
      set clock_target_col [get_clock_info -targets $clock]
      lappend result       [query_collection -report -all $clock_target_col]
      if {$ip_sdc_debug} { post_message -type info "clock_name : $clock_name" }
   }
   if {$ip_sdc_debug} { post_message -type info "PCIe clock_target list: $result" }

   return $result
}



#----------------------------------------
#   CLOCK DEFINITION
#   Unit : ps 
#----------------------------------------
set lite_clk_freq       250
set st_clk_freq         300
set pld_clk_freq        350

set PLD_CLK_PERIOD [format %.3f [expr {double(1000.0/$pld_clk_freq)} ] ]
set LITE_CLK_PERIOD [format %.3f [expr {double(1000.0/$lite_clk_freq)} ] ]
set ST_CLK_PERIOD   [format %.3f [expr {double(1000.0/$st_clk_freq)}   ] ]
set MM_CLK_PERIOD   [format %.3f [expr {double(1000.0/$st_clk_freq)}   ] ]
set REFCLK_PERIOD   10.0

#############
#set ip_inst_name sm_inst|intel_pcie_gts_inst
set dummy_sip_flop_names(0) dummy_out_for_timing_coreclkout_hip
set clk_out_names(0) coreclkout_hip_pld_clk
set clk_ref_names(0) coreclkout_hip_pld_clk_ref
set clk_reg_names(0) coreclkout_hip_pld_clk_reg
set xcvrclk_pin_node(0) [xcvrphy_traverse_fanins $ip_inst_name $dummy_sip_flop_names(0) "pin" ${ip_inst_name} $ip_sdc_debug]
set xcvrclk_ref_node(0) [xcvrphy_traverse_fanins $ip_inst_name $dummy_sip_flop_names(0) "_ref" ${ip_inst_name} $ip_sdc_debug]
set xcvrclk_reg_node(0) [xcvrphy_traverse_fanins $ip_inst_name $dummy_sip_flop_names(0) ".reg" ${ip_inst_name} $ip_sdc_debug]
post_message -type info "TEST SOURCE FOUND $xcvrclk_reg_node(0)"

set all_clocks_list [all_clocks]
        foreach_in_collection clk $all_clocks_list {
                set clk_name [get_clock_info -name $clk]
                if { [is_clock_defined $clk_name] == 1 } {
                        set clk_node_col [get_clock_info -targets $clk_name]

                        foreach_in_collection clk_node $clk_node_col {
                        set clk_node_name [get_node_info -name $clk_node]
                        }
                        post_message -type info "Clock already created $clk_name $clk_node_name"
                                }
        }

#Check if clock with target "syspll_c0_ref" already exists; if yes, get the target node and clock name 
set clk_exists "0"
set clk_exists_node ""
set clk_exists_name ""

set clk_exists [lookup_clock_target $xcvrclk_ref_node(0)]
if {$clk_exists == 1} {
  set clk_exists_name [lookup_clock_target_name $xcvrclk_ref_node(0)]
  set clk_exists_node [get_node_info -name [get_clock_info -target $clk_exists_name]]
  if {$ip_sdc_debug == 1 && $clk_exists == 1} {
    post_message -type info "IP SDC: Clock already created with same target, skipping new clock creation: $clk_exists_name"
    #post_message -type info "Clock already created: NODE: $clk_exists_node"                               
  }
}


#create clock for source ref clock inside HIP
if { $clk_exists == 0 } {
  #create clock if ref node is newly found
  create_clock -name $ip_inst_name|$clk_ref_names(0) -period $PLD_CLK_PERIOD -add $xcvrclk_ref_node(0)
}

#create generated clock for reg clock inside HIP
if { $clk_exists == 0 } {
  #create clock if reg node is newly found
  create_generated_clock -name $ip_inst_name|$clk_reg_names(0) -source $xcvrclk_ref_node(0)  -master_clock $ip_inst_name|$clk_ref_names(0)  -multiply_by 1  -divide_by 1  -duty_cycle 50  -add $xcvrclk_reg_node(0)
} else {
  create_generated_clock -name $ip_inst_name|$clk_reg_names(0) -source $clk_exists_node  -master_clock $clk_exists_name -multiply_by 1  -divide_by 1  -duty_cycle 50  -add $xcvrclk_reg_node(0)
}

#create generated clock for user output clock to Fabric/SIP
create_generated_clock -name $ip_inst_name|$clk_out_names(0) -source $xcvrclk_reg_node(0) -master_clock $ip_inst_name|$clk_reg_names(0)  -multiply_by 1 -divide_by 1 -duty_cycle 50 -add $xcvrclk_pin_node(0)

#Follow Ftile implementation
disable_min_pulse_width [get_clocks $ip_inst_name|$clk_ref_names(0)]
#############
#Refclk creation
set pcie_clock_target_list [pcie_get_clock_target_list $ip_sdc_debug]
#create_clock -name refclk0          -period $REFCLK_PERIOD   [get_ports refclk0]
#create_clock -name refclk1          -period $REFCLK_PERIOD   [get_ports refclk1]
set pcie_refclk0_port_ext  [pcie_port_existence refclk0 $ip_sdc_debug]
set pcie_refclk0_lsrc [lsearch -exact $pcie_clock_target_list refclk0]
if {$pcie_refclk0_port_ext && $pcie_refclk0_lsrc == -1} {
    create_clock -name ${ip_inst_name}_refclk0          -period $REFCLK_PERIOD  -add [get_ports refclk0]
}

#set pcie_refclk1_port_ext  [pcie_port_existence refclk1 $ip_sdc_debug]
#set pcie_refclk1_lsrc [lsearch -exact $pcie_clock_target_list refclk1]
#if {$pcie_refclk1_port_ext && $pcie_refclk1_lsrc == -1} {
#    create_clock -name ${ip_inst_name}_refclk1          -period $REFCLK_PERIOD  -add [get_ports refclk1]
#}



#AXI clock creation
#get all clock list
set pcie_axi_st_clk_port_ext  [pcie_port_existence p*_axi_st_clk $ip_sdc_debug]
set pcie_axi_st_clk_lsrc [lsearch -exact $pcie_clock_target_list ${ip_inst_name}_axi_st_clk]
if {$pcie_axi_st_clk_port_ext && $pcie_axi_st_clk_lsrc == -1} {
    create_clock -name ${ip_inst_name}_axi_st_clk   -period $ST_CLK_PERIOD -add p0_axi_st_clk
}

set pcie_axi_lite_clk_port_ext  [pcie_port_existence p*_axi_lite_clk $ip_sdc_debug]
set pcie_axi_lite_clk_lsrc [lsearch -exact $pcie_clock_target_list ${ip_inst_name}_axi_lite_clk]
if {$pcie_axi_lite_clk_port_ext && $pcie_axi_lite_clk_lsrc == -1} {
    create_clock -name ${ip_inst_name}_axi_lite_clk   -period $LITE_CLK_PERIOD -add p0_axi_lite_clk
    ##create generated clock from axi_lite_clk
    create_generated_clock -name ${ip_inst_name}_avmm_clock0 -source p0_axi_lite_clk -master_clock ${ip_inst_name}_axi_lite_clk -divide_by 2 ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_clock_divider|clkdiv_inst|clock_div2 -add
} else {
    ##the clock source is from higher level
    set dummy_sip_flop_names_axi_lite_clk dummy_out_for_timing_axi_lite_clk
    set clk_src_names_axi_lite_clk [get_clock_source_from_node $ip_inst_name $dummy_sip_flop_names_axi_lite_clk]
    puts $clk_src_names_axi_lite_clk
create_generated_clock -name ${ip_inst_name}_avmm_clock0 -source $clk_src_names_axi_lite_clk -divide_by 2 ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_clock_divider|clkdiv_inst|clock_div2 -add

}

#from ptile pciess sdc
#set_clock_groups -asynchronous -group {avmm_clock0} -group ${ip_inst_name}_axi_lite_clk
###########set_clock_groups -asynchronous -group {avmm_clock0} -group ${ip_inst_name}_axi_st_clk
###########set_clock_groups -asynchronous -group ${ip_inst_name}_axi_st_clk -group ${ip_inst_name}_axi_lite_clk -group $ip_inst_name|$clk_out_names(0)
###########set_clock_groups -asynchronous -group {avmm_clock0} -group {sm_inst|intel_pcie_gts_inst|coreclkout_hip_pld_clk} 

#include for HSD 15014650145
set_false_path -from [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|p0_debounce_logic_inst|gpio_o] -to [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|sm_pcie_hal_top_inst|pcie_hal_top|ch4_phip_inst|x_std_sm_hssi_pld_chnl_dp_0~pldif_reset_reg]

#set false path for setup
#taken out for 23.3 closure
#set_false_path -from [get_keepers -no_duplicates ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_tx_if|sm_pciess_tx.u_pciess_tx_fifo|axi_st_intf_fifo|auto_generated|fifo_altera_syncram|altera_syncram_impl1|ram_block*~reg1] -to [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|sm_pcie_hal_top_inst|pcie_hal_top|one_lane_pcie_inst_0|one_lane_pcie_hal_top_p0|pldif_hal_top_inst|pldif_hal_top|pldif_hal_coreip_inst|gen_sm_ch4_pldif_inst.ch4_pldif_no_deskew_inst|x_std_sm_hssi_pld_chnl_dp_0*]
#falsepath between hip_reconfig clock with coreclkouthip. Crossing happening in the csb. There is a CDC handshake vector sync
set_false_path -from [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|pld_mmioresp_bus_r[*]] -to [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|int_mmio_*]
set_false_path -from [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|mmio_req_bus_r[*]] -to [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|pld_mmio_req_bus_r[*]]
set_max_skew   -from [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|pld_mmioresp_bus_r[*]] -to [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|int_mmio_*] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
set_data_delay -from [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|pld_mmioresp_bus_r[*]] -to [get_keepers -no_duplicates ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_csb_adaptor_inst|avmm_inst|int_mmio_*] -get_value_from_clock_period dst_clock_period -value_multiplier 0.9

#falsepath async reset which driven from src. The domain is coreclkout_hip to hip_reconfig clk. The clrn expecting async reset. It is ok to waive because the reset is pseudo static
proc apply_sdc_synchronizer_clrn_false_path {sync_name} {
  if {[get_collection_size [get_keepers -nowarn ${sync_name}]] > 0} {
    puts "${sync_name} is found"
    set_false_path -through [get_pins ${sync_name}|clrn] -to [get_keepers -no_duplicates ${sync_name}]
     }
}
#coreclkout <--> axi_st_clk
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|SM_TXCRDT.u_warm_rst_coreclk_n_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_ext_ctrl_shadow|u_coreclkout_hip_reset_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_vf_err_if|u_warm_rst_coreclk_n_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_warm_rst_coreclk_n_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_core_rst_coreclk_n_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_tx_if|sm_pciess_tx.u_pciess_tx_fifo|axi_st_intf_fifo|auto_generated|rdaclr|dffe1*a[0]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_ext_ctrl_shadow|ctrlshadow_fifo_inst|auto_generated|wraclr|dffe1*a[0]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_rx_if|u_pciess_rx_fifo|u_ss_app_st_rx_fifo|auto_generated|wraclr|dffe1*a[0] 
#axi_st_clk <--> axi_lite_clk
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_ext_ctrl_shadow|u_axi_lite_clk_reset_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_warm_rst_liteclk2_n_sync|dreg[*]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_warm_rst_liteclk_n_sync|dreg[*] 
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_core_rst_liteclk_n_sync|dreg[*]
#avmm_clk <--> axi_lite_clk
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_axi_lite_clk_to_user_avmm_clk_fifo|auto_generated|wraclr|dffe1*a[0]
apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|u_pciess_p0|gen_sub.u_hipif|u_pciess_cfg_if|u_warm_rst_avmmclk_n_sync|dreg[*]
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|
#apply_sdc_synchronizer_clrn_false_path ${ip_inst_name}|



proc apply_sdc_synchronizer_nocut_false_path {sync_name ip_inst_name} {
puts ${sync_name}
  if {[get_collection_size [get_keepers -nowarn ${sync_name}|din_s1]] > 0} {
    puts "${sync_name} is found"
    set_false_path -to [get_registers ${sync_name}|din_s1]
    if {[string match [string map { \[ \\\[ \] \\\] } ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|sm_pcie_src_inst|pld_clk_ninit_done_sync_inst] ${sync_name}]} {

    } elseif {[string match [string map { \[ \\\[ \] \\\] } ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|pcie_sip_top_inst|avmm_rst_sync_inst] ${sync_name}]} {

    } elseif {[string match [string map { \[ \\\[ \] \\\] } ${ip_inst_name}|gen_sm_qhip.u_sm_qhip|i_gpio_perst0_n_sync_inst] ${sync_name}]} {

    } else { 
      set_data_delay -to [get_registers ${sync_name}|din_s1] -get_value_from_clock_period dst_clock_period -value_multiplier 0.9
    }
    apply_sdc_synchronizer_clrn_false_path ${sync_name}|dreg[*]
     }
}

#apply false path to all altera_std_synchronizer_nocut cross clock data path
set sync_nocut_list [get_entity_instances altera_std_synchronizer_nocut]

foreach each_inst ${sync_nocut_list} {
#pattern match to ensure only apply falsepath to synchronizer inside the dut
       if { [string match [string map { \[ \\\[ \] \\\] } ${ip_inst_name}*] ${each_inst}] } {
          puts "apply synchronize false path to ${each_inst}"
          apply_sdc_synchronizer_nocut_false_path ${each_inst} ${ip_inst_name}
       }
    }

#apply false path to all hssi_ss_std_synchronizer_nocut cross clock data path
set sync_nocut_list [get_entity_instances hssi_ss_std_synchronizer_nocut]

foreach each_inst ${sync_nocut_list} {
#pattern match to ensure only apply falsepath to synchronizer inside the dut
       if { [string match [string map { \[ \\\[ \] \\\] } ${ip_inst_name}*] ${each_inst}] } {
          puts "apply synchronize false path to ${each_inst}"
          apply_sdc_synchronizer_nocut_false_path ${each_inst} ${ip_inst_name}
       }
    }


#to falsepath vector sync

proc apply_sdc_vectorsync_false_path {vectorsync_name} {
puts ${vectorsync_name}

  if {[get_collection_size [get_keepers -nowarn ${vectorsync_name}|*data_in_d1*]] > 0} {
     puts "${vectorsync_name} is found"
	  #Recommended by CDC Crossing
     set_false_path -from [get_registers ${vectorsync_name}|*data_in_d1*] -to [get_registers ${vectorsync_name}|data_out*]
	  set_max_skew   -from [get_registers ${vectorsync_name}|*data_in_d1*] -to [get_registers ${vectorsync_name}|data_out*] -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
	  set_data_delay -from [get_registers ${vectorsync_name}|*data_in_d1*] -to [get_registers ${vectorsync_name}|data_out*] -get_value_from_clock_period dst_clock_period -value_multiplier 0.9
     }

}

#apply false path to all pciess_vecsync cross clock data path
set vector_list [get_entity_instances pciess_vecsync]

foreach each_inst ${vector_list} {

        apply_sdc_vectorsync_false_path ${each_inst}

    }


#apply false path to all pciess_vecsync_handshake cross clock data path
set vector_list [get_entity_instances pciess_vecsync_handshake]

foreach each_inst ${vector_list} {

        apply_sdc_vectorsync_false_path ${each_inst}

    }



##klai4 taken out because only power user mode. axi_mm_clk not needed
#create_clock -name p0_axi_mm_clk    -period $MM_CLK_PERIOD   [get_ports p0_axi_mm_clk]

############START##################
##klai4 taken out for initial sm
#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        create_clock -name p1_axi_st_clk    -period $ST_CLK_PERIOD   [get_ports p1_axi_st_clk]
#}
#if {[regexp "x4" $top_topology]} {
#        create_clock -name p2_axi_st_clk    -period $ST_CLK_PERIOD   [get_ports p2_axi_st_clk]
#        create_clock -name p3_axi_st_clk    -period $ST_CLK_PERIOD   [get_ports p3_axi_st_clk]
#}

#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        create_clock -name p1_axi_lite_clk  -period $LITE_CLK_PERIOD [get_ports p1_axi_lite_clk]
#}
#if {[regexp "x4" $top_topology]} {
#        create_clock -name p2_axi_lite_clk  -period $LITE_CLK_PERIOD [get_ports p2_axi_lite_clk]
#        create_clock -name p3_axi_lite_clk  -period $LITE_CLK_PERIOD [get_ports p3_axi_lite_clk]
#}

#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        create_clock -name p1_axi_mm_clk    -period $MM_CLK_PERIOD   [get_ports p1_axi_mm_clk]
#}
#if {[regexp "x4" $top_topology]} {
#        create_clock -name p2_axi_mm_clk    -period $MM_CLK_PERIOD   [get_ports p2_axi_mm_clk]
#        create_clock -name p3_axi_mm_clk    -period $MM_CLK_PERIOD   [get_ports p3_axi_mm_clk]
#}
#############END###################

##This is for the implementation for HIP_RECONFIG. Not sure if the divider still active. NK to help checking it. Commented out for now
##create_generated_clock -name avmm_clock0 -source p0_axi_lite_clk -master_clock p0_axi_lite_clk -divide_by 2 \
##        ${pcie_ss_inst}|u_pciess_p0|gen_sub.u_hipif|u_pciess_clock_divider|clkdiv_inst|clock_div2 -add

############START##################
##klai4 taken out for initial sm
#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        create_generated_clock -name avmm_clock1 -source p1_axi_lite_clk -master_clock p1_axi_lite_clk -divide_by 2 \
#                ${pcie_ss_inst}|gen_pciess_p1.u_pciess_p1|gen_sub.u_hipif|u_pciess_clock_divider|clkdiv_inst|clock_div2 -add
#}
#if {[regexp "x4" $top_topology]} {
#        create_generated_clock -name avmm_clock2 -source p2_axi_lite_clk -master_clock p2_axi_lite_clk -divide_by 2 \
#                ${pcie_ss_inst}|gen_pciess_p2_p3.u_pciess_p2|gen_sub.u_hipif|u_pciess_clock_divider|clkdiv_inst|clock_div2 -add

#        create_generated_clock -name avmm_clock3 -source p3_axi_lite_clk -master_clock p3_axi_lite_clk -divide_by 2 \
#                ${pcie_ss_inst}|gen_pciess_p2_p3.u_pciess_p3|gen_sub.u_hipif|u_pciess_clock_divider|clkdiv_inst|clock_div2 -add
#}
#############END###################

##klai4 commented out as the avmm_clock0 is taken out temporarily
##set_clock_groups -asynchronous -group {avmm_clock0} -group {p0_axi_lite_clk}

############START##################
##klai4 taken out for initial sm
#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#	set_clock_groups -asynchronous -group {avmm_clock1} -group {p1_axi_lite_clk}
#}
#if {[regexp "x4" $top_topology]} {
#	set_clock_groups -asynchronous -group {avmm_clock2} -group {p2_axi_lite_clk}
#	set_clock_groups -asynchronous -group {avmm_clock3} -group {p3_axi_lite_clk}
#}
#############END###################

############START##################
##klai4 taken out for initial sm
#if {$debug_toolkit_en} {
#        set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#        set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p0_axi_lite_clk
#        set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p0_axi_st_clk

#        if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#                set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p1_axi_lite_clk
#                set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p1_axi_st_clk
#        }
#        if {[regexp "x4" $top_topology]} {
#                set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p2_axi_lite_clk
#                set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p3_axi_lite_clk
#                set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p2_axi_st_clk
#                set_clock_groups -asynchronous -group [get_clocks {xcvr_reconfig_clk}] -group p3_axi_st_clk
#        }
#}
#############END###################
##klai4 disable clock group for now
#set_clock_groups -asynchronous -group {p0_axi_st_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#set_clock_groups -asynchronous -group {p0_axi_lite_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#set_clock_groups -asynchronous -group {avmm_clock0} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#set_clock_groups -asynchronous -group {p0_axi_lite_clk} -group {p0_axi_st_clk}
##set_clock_groups -asynchronous -group {p0_axi_st_clk} -group {avmm_clock0}


############START##################
##klai4 taken out for initial sm
#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p1_axi_st_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#}
#if {[regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p2_axi_st_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#        set_clock_groups -asynchronous -group {p3_axi_st_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#}

#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p1_axi_lite_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#}
#if {[regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p2_axi_lite_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#        set_clock_groups -asynchronous -group {p3_axi_lite_clk} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#}

#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {avmm_clock1} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#}
#if {[regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {avmm_clock2} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#        set_clock_groups -asynchronous -group {avmm_clock3} -group ${pcie_ss_inst}|gen_ptile.u_ptile|intel_pcie_ptile_ast_qhip|inst|inst|maib_and_tile|xcvr_hip_native|rx_ch15
#}

#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p1_axi_lite_clk} -group {p1_axi_st_clk}
#}
#if {[regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p2_axi_lite_clk} -group {p2_axi_st_clk}
#        set_clock_groups -asynchronous -group {p3_axi_lite_clk} -group {p3_axi_st_clk}
#}

#if {[regexp "2x8" $top_topology] || [regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p1_axi_st_clk} -group {avmm_clock1}
#}
#if {[regexp "x4" $top_topology]} {
#        set_clock_groups -asynchronous -group {p2_axi_st_clk} -group {avmm_clock2}
#        set_clock_groups -asynchronous -group {p3_axi_st_clk} -group {avmm_clock3}
#}
#############END###################

##TO ADD##
##set_false_path for synchronizer
##SDC for DCFIFO
##set_disable_min_pulse

# constraints for DCFIFO sdc
#
# top-level sdc
# convention for module sdc apply_sdc_<module_name>
#
proc apply_sdc_dcfifo {ip_inst_name} {
# gray_rdptr
apply_sdc_dcfifo_rdptr ${ip_inst_name}
# gray_wrptr
apply_sdc_dcfifo_wrptr ${ip_inst_name}
}
#
# common constraint setting proc
#
proc apply_sdc_dcfifo_for_ptrs {from_node_list to_node_list} {
# control skew for bits
set_max_skew -from ${from_node_list} -to ${to_node_list} -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
# path delay (exception for net delay)
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from ${from_node_list} -to ${to_node_list} -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
#relax setup and hold calculation
set_max_delay -from ${from_node_list} -to ${to_node_list} 100
set_min_delay -from ${from_node_list} -to ${to_node_list} -100
}
#
# mstable propgation delay
#
proc apply_sdc_dcfifo_mstable_delay {from_node_list to_node_list} {
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from ${from_node_list} -to ${to_node_list} -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
}
#
# rdptr constraints
#
proc apply_sdc_dcfifo_rdptr {ip_inst_name} {
set rdptr_from 0
set rdptr_to 0
set ws_dgrp_from 0
set ws_dgrp_to 0
# get from and to list
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|*rdptr_g*]] > 0} {
set from_node_list [get_keepers ${ip_inst_name}|auto_generated|*rdptr_g*]
set rdptr_from 1
}
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|ws_dgrp|dffpipe*|dffe*]] > 0} {
set to_node_list [get_keepers ${ip_inst_name}|auto_generated|ws_dgrp|dffpipe*|dffe*]
set rdptr_to 1
}
if { ${rdptr_from} == 1 && ${rdptr_to} == 1} {
apply_sdc_dcfifo_for_ptrs ${from_node_list} ${to_node_list}
}
# mstable
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|ws_dgrp|dffpipe*|dffe*]] > 0} {
set from_node_mstable_list [get_keepers ${ip_inst_name}|auto_generated|ws_dgrp|dffpipe*|dffe*]
set ws_dgrp_from 1
}
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|ws_dgrp|dffpipe*|dffe*]] > 0} {
set to_node_mstable_list [get_keepers ${ip_inst_name}|auto_generated|ws_dgrp|dffpipe*|dffe*]
set ws_dgrp_to 1
}
if {${ws_dgrp_from} == 1 && ${ws_dgrp_to} == 1} {
apply_sdc_dcfifo_mstable_delay ${from_node_mstable_list} ${to_node_mstable_list}
}

}
#
# wrptr constraints
#
proc apply_sdc_dcfifo_wrptr {ip_inst_name} {
set dffe_from 0
set dffe_to 0
set delayed_wrptr_g_from 0
# control skew for bits
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|delayed_wrptr_g*]] > 0} {
set from_node_list [get_keepers ${ip_inst_name}|auto_generated|delayed_wrptr_g*]
set delayed_wrptr_g_from 1
}
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|rs_dgwp|dffpipe*|dffe*]] > 0} {
set to_node_list [get_keepers ${ip_inst_name}|auto_generated|rs_dgwp|dffpipe*|dffe*]
set dffe_to 1
}
if {${delayed_wrptr_g_from} == 1 && ${dffe_to} == 1} {
apply_sdc_dcfifo_for_ptrs ${from_node_list} ${to_node_list}
}
# mstable
set dffe_to 0
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|rs_dgwp|dffpipe*|dffe*]] > 0} {
set from_node_mstable_list [get_keepers ${ip_inst_name}|auto_generated|rs_dgwp|dffpipe*|dffe*]
set dffe_from 1
}
if {[get_collection_size [get_keepers -nowarn ${ip_inst_name}|auto_generated|rs_dgwp|dffpipe*|dffe*]] > 0} {
set to_node_mstable_list [get_keepers ${ip_inst_name}|auto_generated|rs_dgwp|dffpipe*|dffe*]
set dffe_to 1
}
if { ${dffe_from} == 1 && ${dffe_to} == 1} {
apply_sdc_dcfifo_mstable_delay ${from_node_mstable_list} ${to_node_mstable_list}
}

}
#proc apply_sdc_pre_dcfifo {entity_name} {

set inst_list [get_entity_instances dcfifo]

foreach each_inst ${inst_list} {

        apply_sdc_dcfifo ${each_inst}

    }
#}
#apply_sdc_pre_dcfifo reorder_to_dcfifo_fifo_1910_sy3r64a

 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 14 pcie_ed_iopll0 17 altera_iopll_1931 5 synth 44 pcie_ed_iopll0_altera_iopll_1931_klgmlua.sdc 7765 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the timing constraints for the Altera PLL.
#    * The helper routines are defined in pcie_ed_iopll0_altera_iopll_1931_klgmlua_pin_map.tcl
#
# NOTE
# ----
# Debug switch. Change to 1 to get more run-time debug information
set debug 0

set script_dir [file dirname [info script]]

source "$script_dir/pcie_ed_iopll0_altera_iopll_1931_klgmlua_parameters.tcl"
source "$script_dir/pcie_ed_iopll0_altera_iopll_1931_klgmlua_pin_map.tcl"

####################
#                  #
# GENERAL SETTINGS #
#                  #
####################

# This is a global setting and will apply to the whole design.
# This setting is required for the memory interface to be
# properly constrained.
derive_clock_uncertainty


# All timing requirements will be represented in nanoseconds with up to 3 decimal places of precision
set_time_format -unit ns -decimal_places 3

# Determine if entity names are on
set entity_names_on [ ai_are_entity_names_on ]

if {[catch {load_package atoms
            load_package sdc_ext
            load_package design
            catch {read_atom_netlist} read_atom_netlist_out
            set read_atom_netlist_error [regexp "ERROR" $read_atom_netlist_out]
            } err_loading_packages]} {
    post_message -type error "Failed to load packages required by IOPLL SDC: $err_loading_packages"
}

# This is the main call to the netlist traversal routines
# that will automatically find all pins and registers required
# to apply timing constraints.
# During the fitter, the routines will be called only once
# and cached data will be used in all subsequent calls.



if {[info exists ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_ai_pll_db]} {
    # Clean-up stale content
    unset ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_ai_pll_db
}
if {[catch {ai_initialize_pll_db ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_ai_pll_db} err_initializing_db]} {
    post_message -type warning "Failed to find atom information in IOPLL SDC: $err_initializing_db"
}

# If multiple instances of this core are present in the
# design they will all be constrained through the
# following loop
set instances [ array names ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_ai_pll_db ]
foreach { inst } $instances {
	if { [ info exists pins ] } {
		# Clean-up stale content
		unset pins
	}
	
	# -------------------------------- #
	# -                              - #
	# --- Determine PLL Parameters --- #
	# -                              - #
	# -------------------------------- #
	
	set pll_atoms [get_atom_nodes -matching ${inst}* -type IOPLL]
	set num_pll_inst [get_collection_size $pll_atoms]
	
	if {$num_pll_inst > 1} { 
		# Error condition
		post_message -type error "SDC: More than one PLL atom found with instance name $inst"
	} else {
		# Use IP generated parameters
		if { $debug } {
			post_message -type info "SDC: using IP generated parameter values"
		}
	}

    # These dictionaries hold all the clock information.
    lassign $::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_ai_pll_db($inst) base_clock_data_dict gen_clock_data_dict
	
	# ------------------------ #
	# -                      - #
	# ---REFERENCE CLOCK(s)--- #
	# -                      - #
	# ------------------------ #
    dict for {clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_fpga_pin && !$exists} {
               create_clock -period $period \
                   -waveform [ list 0 $half_period] \
                   -name $name $port_node_name \
                   -add
            }
        }
    }
	# ------------------------- #
	# -                       - #
	# --- OUTPUT PLL CLOCKS --- #
	# -                       - #
	# ------------------------- #
    set refclk_iterm_dict [dict create]
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            if {[is_post_syn_sta]} {
                if {$is_valid && !$exists} {
                    create_non_virtual_generated_clock_with_master_or_source \
                        $master \
                        $src \
                        $name \
                        $multiply_by \
                        $divide_by \
                        $phase \
                        $duty_cycle \
                        $pin_node_name

                    if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {
                        set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                    }
                } elseif {[is_m_n_cntr $pattern]} {
                    create_virtual_generated_clock_with_master_or_source \
                        $master \
                        $src \
                        $name \
                        $multiply_by \
                        $divide_by \
                        $phase \
                        $duty_cycle
                }
            } else {
                if {$is_valid && !$exists} {
                    
                    regexp -- {^(.*tennm_ph2_iopll)} $pin_node_name -> refclk_hier
                    set refclk_src "${refclk_hier}|ref_clk0"
                    set master_clock [get_master_clock_given_refclk_src $refclk_src]

                    if {![dict exists $refclk_iterm_dict $refclk_src]} {
                        create_generated_clock -add \
                            -source $src \
                            -master_clock $master_clock \
                            $refclk_src
                        dict set refclk_iterm_dict $refclk_src $src
                    }
                    if {$src ==  [dict get $refclk_iterm_dict $refclk_src]} {
                        set src $refclk_src
                    }
                    create_generated_clock -add \
                        -source $src \
                        -name $name \
                        -multiply_by $multiply_by \
                        -divide_by $divide_by \
                        -phase $phase \
                        -duty_cycle $duty_cycle \
                        $pin_node_name
                    
                    if {[string match lvds* $clock_key] && [string match *loaden* $pattern] && [dict exists $gen_clock_data_dict $clock_key "through_pin" ] } {
                        set_max_delay_in_fit_or_false_path_in_sta_through_no_warn $through_pin $max_delay
                    }
                }
            }
        }
    }

    foreach_in_collection node [get_nodes -no_duplicates -nowarn "${inst}|tennm_ph2_iopll|reset"] {
        set_false_path -through [get_node_info -name $node]
    }
}
 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 14 pcie_ed_iopll0 17 altera_iopll_1931 5 synth 58 pcie_ed_iopll0_altera_iopll_1931_klgmlua_all_ip_params.tcl 50833 # PLL parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!

set ::pll_corename pcie_ed_iopll0_altera_iopll_1931_klgmlua

set ::pll_all_ip_params [dict create]

dict set ::pll_all_ip_params gui_device_family "Agilex 5"
dict set ::pll_all_ip_params gui_device_component "A5ED065BB32AE4SR0"
dict set ::pll_all_ip_params gui_device_speed_grade "4"
dict set ::pll_all_ip_params gui_device_iobank_rev "IO96B"
dict set ::pll_all_ip_params gui_debug_mode "false"
dict set ::pll_all_ip_params gui_skip_sdc_generation "false"
dict set ::pll_all_ip_params gui_include_iossm "false"
dict set ::pll_all_ip_params gui_cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params gui_parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params gui_pll_tclk_mux_en "false"
dict set ::pll_all_ip_params gui_pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params gui_pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params gui_pll_freqcal_en "true"
dict set ::pll_all_ip_params gui_pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params gui_cal_converge "false"
dict set ::pll_all_ip_params gui_cal_error "cal_clean"
dict set ::pll_all_ip_params gui_pll_cal_done "false"
dict set ::pll_all_ip_params gui_pll_type "S10_Simple"
dict set ::pll_all_ip_params gui_pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params gui_c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params system_info_device_family "Agilex 5"
dict set ::pll_all_ip_params system_info_device_component "A5ED065BB32AE4SR0"
dict set ::pll_all_ip_params system_info_device_speed_grade "4"
dict set ::pll_all_ip_params system_part_trait_speed_grade "4"
dict set ::pll_all_ip_params system_part_trait_iobank_rev "IO96B"
dict set ::pll_all_ip_params gui_usr_device_speed_grade "1"
dict set ::pll_all_ip_params gui_en_reconf "false"
dict set ::pll_all_ip_params gui_en_iossm_reconf "false"
dict set ::pll_all_ip_params gui_user_base_address "0"
dict set ::pll_all_ip_params gui_en_dps_ports "false"
dict set ::pll_all_ip_params gui_pll_mode "Integer-N PLL"
dict set ::pll_all_ip_params gui_location_type "I/O Bank"
dict set ::pll_all_ip_params gui_use_logical "false"
dict set ::pll_all_ip_params gui_reference_clock_frequency "100.0"
dict set ::pll_all_ip_params gui_reference_clock_frequency_ps "10000.0"
dict set ::pll_all_ip_params gui_use_coreclk "false"
dict set ::pll_all_ip_params gui_refclk_might_change "false"
dict set ::pll_all_ip_params gui_fractional_cout "32"
dict set ::pll_all_ip_params gui_prot_mode "UNUSED"
dict set ::pll_all_ip_params gui_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params gui_use_locked "true"
dict set ::pll_all_ip_params gui_en_adv_params "false"
dict set ::pll_all_ip_params gui_pll_bandwidth_preset "Low"
dict set ::pll_all_ip_params gui_lock_setting "Low Lock Time"
dict set ::pll_all_ip_params gui_pll_auto_reset "false"
dict set ::pll_all_ip_params gui_en_lvds_ports "Disabled"
dict set ::pll_all_ip_params gui_en_periphery_ports "false"
dict set ::pll_all_ip_params gui_operation_mode "direct"
dict set ::pll_all_ip_params gui_feedback_clock "Global Clock"
dict set ::pll_all_ip_params gui_clock_to_compensate "0"
dict set ::pll_all_ip_params gui_use_NDFB_modes "false"
dict set ::pll_all_ip_params gui_refclk_switch "false"
dict set ::pll_all_ip_params gui_refclk1_frequency "100.0"
dict set ::pll_all_ip_params gui_en_phout_ports "false"
dict set ::pll_all_ip_params gui_phout_division "1"
dict set ::pll_all_ip_params gui_en_extclkout_ports "false"
dict set ::pll_all_ip_params gui_number_of_clocks "2"
dict set ::pll_all_ip_params gui_multiply_factor "6"
dict set ::pll_all_ip_params gui_divide_factor_n "1"
dict set ::pll_all_ip_params gui_frac_multiply_factor "1"
dict set ::pll_all_ip_params gui_fix_vco_frequency "true"
dict set ::pll_all_ip_params gui_fixed_vco_frequency "1410.0"
dict set ::pll_all_ip_params gui_fixed_vco_frequency_ps "1667.0"
dict set ::pll_all_ip_params gui_vco_frequency "600.0"
dict set ::pll_all_ip_params gui_enable_output_counter_cascading "false"
dict set ::pll_all_ip_params gui_mif_gen_options "Generate New MIF File"
dict set ::pll_all_ip_params gui_new_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_existing_mif_file_path "~/pll.mif"
dict set ::pll_all_ip_params gui_mif_config_name "unnamed"
dict set ::pll_all_ip_params gui_active_clk "false"
dict set ::pll_all_ip_params gui_clk_bad "false"
dict set ::pll_all_ip_params gui_switchover_mode "Automatic Switchover"
dict set ::pll_all_ip_params gui_switchover_delay "0"
dict set ::pll_all_ip_params gui_enable_cascade_out "false"
dict set ::pll_all_ip_params gui_cascade_outclk_index "0"
dict set ::pll_all_ip_params gui_enable_cascade_in "false"
dict set ::pll_all_ip_params gui_enable_permit_cal "false"
dict set ::pll_all_ip_params gui_enable_upstream_out_clk "false"
dict set ::pll_all_ip_params gui_pll_cascading_mode "adjpllin"
dict set ::pll_all_ip_params gui_enable_mif_dps "false"
dict set ::pll_all_ip_params gui_dps_cntr "C0"
dict set ::pll_all_ip_params gui_dps_num "1"
dict set ::pll_all_ip_params gui_dps_dir "Positive"
dict set ::pll_all_ip_params gui_extclkout_0_source "C0"
dict set ::pll_all_ip_params gui_extclkout_1_source "C0"
dict set ::pll_all_ip_params gui_extclkout_source "C0"
dict set ::pll_all_ip_params gui_clock_name_global "false"
dict set ::pll_all_ip_params gui_clock_name_string0 "outclk0"
dict set ::pll_all_ip_params gui_clock_name_string1 "outclk1"
dict set ::pll_all_ip_params gui_clock_name_string2 "outclk2"
dict set ::pll_all_ip_params gui_clock_name_string3 "outclk3"
dict set ::pll_all_ip_params gui_clock_name_string4 "outclk4"
dict set ::pll_all_ip_params gui_clock_name_string5 "outclk5"
dict set ::pll_all_ip_params gui_clock_name_string6 "outclk6"
dict set ::pll_all_ip_params gui_clock_name_string7 "outclk7"
dict set ::pll_all_ip_params gui_clock_name_string8 "outclk8"
dict set ::pll_all_ip_params gui_clock_name_string9 "outclk9"
dict set ::pll_all_ip_params gui_clock_name_string10 "outclk10"
dict set ::pll_all_ip_params gui_clock_name_string11 "outclk11"
dict set ::pll_all_ip_params gui_clock_name_string12 "outclk12"
dict set ::pll_all_ip_params gui_clock_name_string13 "outclk13"
dict set ::pll_all_ip_params gui_clock_name_string14 "outclk14"
dict set ::pll_all_ip_params gui_clock_name_string15 "outclk15"
dict set ::pll_all_ip_params gui_clock_name_string16 "outclk16"
dict set ::pll_all_ip_params gui_clock_name_string17 "outclk17"
dict set ::pll_all_ip_params gui_divide_factor_c0 "6"
dict set ::pll_all_ip_params gui_divide_factor_c1 "6"
dict set ::pll_all_ip_params gui_divide_factor_c2 "6"
dict set ::pll_all_ip_params gui_divide_factor_c3 "6"
dict set ::pll_all_ip_params gui_divide_factor_c4 "6"
dict set ::pll_all_ip_params gui_divide_factor_c5 "6"
dict set ::pll_all_ip_params gui_divide_factor_c6 "6"
dict set ::pll_all_ip_params gui_divide_factor_c7 "6"
dict set ::pll_all_ip_params gui_divide_factor_c8 "6"
dict set ::pll_all_ip_params gui_divide_factor_c9 "6"
dict set ::pll_all_ip_params gui_divide_factor_c10 "6"
dict set ::pll_all_ip_params gui_divide_factor_c11 "6"
dict set ::pll_all_ip_params gui_divide_factor_c12 "6"
dict set ::pll_all_ip_params gui_divide_factor_c13 "6"
dict set ::pll_all_ip_params gui_divide_factor_c14 "6"
dict set ::pll_all_ip_params gui_divide_factor_c15 "6"
dict set ::pll_all_ip_params gui_divide_factor_c16 "6"
dict set ::pll_all_ip_params gui_divide_factor_c17 "6"
dict set ::pll_all_ip_params gui_cascade_counter0 "false"
dict set ::pll_all_ip_params gui_cascade_counter1 "false"
dict set ::pll_all_ip_params gui_cascade_counter2 "false"
dict set ::pll_all_ip_params gui_cascade_counter3 "false"
dict set ::pll_all_ip_params gui_cascade_counter4 "false"
dict set ::pll_all_ip_params gui_cascade_counter5 "false"
dict set ::pll_all_ip_params gui_cascade_counter6 "false"
dict set ::pll_all_ip_params gui_cascade_counter7 "false"
dict set ::pll_all_ip_params gui_cascade_counter8 "false"
dict set ::pll_all_ip_params gui_cascade_counter9 "false"
dict set ::pll_all_ip_params gui_cascade_counter10 "false"
dict set ::pll_all_ip_params gui_cascade_counter11 "false"
dict set ::pll_all_ip_params gui_cascade_counter12 "false"
dict set ::pll_all_ip_params gui_cascade_counter13 "false"
dict set ::pll_all_ip_params gui_cascade_counter14 "false"
dict set ::pll_all_ip_params gui_cascade_counter15 "false"
dict set ::pll_all_ip_params gui_cascade_counter16 "false"
dict set ::pll_all_ip_params gui_cascade_counter17 "false"
dict set ::pll_all_ip_params gui_output_clock_frequency0 "250.0"
dict set ::pll_all_ip_params gui_output_clock_frequency1 "350.0"
dict set ::pll_all_ip_params gui_output_clock_frequency2 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency3 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency4 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps0 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps1 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps2 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps3 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps4 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps5 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps6 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps7 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps8 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps9 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps10 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps11 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps12 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps13 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps14 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps15 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps16 "10000.0"
dict set ::pll_all_ip_params gui_output_clock_frequency_ps17 "10000.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency0 "235.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency1 "352.5"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency2 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency3 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency4 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency17 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range0 "176.25 201.428571 235.0 282.0 352.5 470.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range1 "201.428571 235.0 282.0 352.5 470.0 705.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range2 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range3 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range4 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range5 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range6 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range7 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range8 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range9 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range10 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range11 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range12 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range13 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range14 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range15 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range16 "100.0"
dict set ::pll_all_ip_params gui_actual_output_clock_frequency_range17 "100.0"
dict set ::pll_all_ip_params gui_ps_units0 "ps"
dict set ::pll_all_ip_params gui_ps_units1 "ps"
dict set ::pll_all_ip_params gui_ps_units2 "ps"
dict set ::pll_all_ip_params gui_ps_units3 "ps"
dict set ::pll_all_ip_params gui_ps_units4 "ps"
dict set ::pll_all_ip_params gui_ps_units5 "ps"
dict set ::pll_all_ip_params gui_ps_units6 "ps"
dict set ::pll_all_ip_params gui_ps_units7 "ps"
dict set ::pll_all_ip_params gui_ps_units8 "ps"
dict set ::pll_all_ip_params gui_ps_units9 "ps"
dict set ::pll_all_ip_params gui_ps_units10 "ps"
dict set ::pll_all_ip_params gui_ps_units11 "ps"
dict set ::pll_all_ip_params gui_ps_units12 "ps"
dict set ::pll_all_ip_params gui_ps_units13 "ps"
dict set ::pll_all_ip_params gui_ps_units14 "ps"
dict set ::pll_all_ip_params gui_ps_units15 "ps"
dict set ::pll_all_ip_params gui_ps_units16 "ps"
dict set ::pll_all_ip_params gui_ps_units17 "ps"
dict set ::pll_all_ip_params gui_phase_shift0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift3 "0.0"
dict set ::pll_all_ip_params gui_phase_shift4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg3 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift0 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift1 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range0 "0.0 88.7 177.3 266.0 354.6 443.3"
dict set ::pll_all_ip_params gui_actual_phase_shift_range1 "0.0 88.7 177.3 266.0 354.6 443.3"
dict set ::pll_all_ip_params gui_actual_phase_shift_range2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_range17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg0 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg1 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg17 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range0 "0.0 7.5 15.0 22.5 30.0 37.5"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range1 "0.0 11.3 22.5 33.8 45.0 56.2"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range2 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range3 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range4 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range5 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range6 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range7 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range8 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range9 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range10 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range11 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range12 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range13 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range14 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range15 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range16 "0.0"
dict set ::pll_all_ip_params gui_actual_phase_shift_deg_range17 "0.0"
dict set ::pll_all_ip_params gui_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle1 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle3 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle0 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle1 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle3 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle4 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle17 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range0 "25.0 33.33 41.67 50.0 58.33 66.67"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range1 "12.5 25.0 37.5 50.0 62.5 75.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range2 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range3 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range4 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range5 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range6 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range7 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range8 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range9 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range10 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range11 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range12 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range13 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range14 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range15 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range16 "50.0"
dict set ::pll_all_ip_params gui_actual_duty_cycle_range17 "50.0"
dict set ::pll_all_ip_params gui_simulation_type "false"
dict set ::pll_all_ip_params parameterTable_names "{M-Counter Divide Setting} {N-Counter Divide Setting} {VCO Frequency} {C-Counter-0 Divide Setting} {C-Counter-1 Divide Setting} {C-Counter-2 Divide Setting} {C-Counter-3 Divide Setting} {C-Counter-4 Divide Setting} {C-Counter-5 Divide Setting} {C-Counter-6 Divide Setting} {C-Counter-7 Divide Setting} {C-Counter-8 Divide Setting} {PLL Auto Reset} {M-Counter Hi Divide} {M-Counter Lo Divide} {M-Counter Even Duty Enable} {M-Counter Bypass Enable} {N-Counter Hi Divide} {N-Counter Lo Divide} {N-Counter Even Duty Enable} {N-Counter Bypass Enable} {C-Counter-0 Hi Divide} {C-Counter-1 Hi Divide} {C-Counter-2 Hi Divide} {C-Counter-3 Hi Divide} {C-Counter-4 Hi Divide} {C-Counter-5 Hi Divide} {C-Counter-6 Hi Divide} {C-Counter-7 Hi Divide} {C-Counter-8 Hi Divide} {C-Counter-0 Lo Divide} {C-Counter-1 Lo Divide} {C-Counter-2 Lo Divide} {C-Counter-3 Lo Divide} {C-Counter-4 Lo Divide} {C-Counter-5 Lo Divide} {C-Counter-6 Lo Divide} {C-Counter-7 Lo Divide} {C-Counter-8 Lo Divide} {C-Counter-0 Even Duty Enable} {C-Counter-1 Even Duty Enable} {C-Counter-2 Even Duty Enable} {C-Counter-3 Even Duty Enable} {C-Counter-4 Even Duty Enable} {C-Counter-5 Even Duty Enable} {C-Counter-6 Even Duty Enable} {C-Counter-7 Even Duty Enable} {C-Counter-8 Even Duty Enable} {C-Counter-0 Bypass Enable} {C-Counter-1 Bypass Enable} {C-Counter-2 Bypass Enable} {C-Counter-3 Bypass Enable} {C-Counter-4 Bypass Enable} {C-Counter-5 Bypass Enable} {C-Counter-6 Bypass Enable} {C-Counter-7 Bypass Enable} {C-Counter-8 Bypass Enable} {C-Counter-0 Preset} {C-Counter-1 Preset} {C-Counter-2 Preset} {C-Counter-3 Preset} {C-Counter-4 Preset} {C-Counter-5 Preset} {C-Counter-6 Preset} {C-Counter-7 Preset} {C-Counter-8 Preset} {C-Counter-0 Phase Mux Preset} {C-Counter-1 Phase Mux Preset} {C-Counter-2 Phase Mux Preset} {C-Counter-3 Phase Mux Preset} {C-Counter-4 Phase Mux Preset} {C-Counter-5 Phase Mux Preset} {C-Counter-6 Phase Mux Preset} {C-Counter-7 Phase Mux Preset} {C-Counter-8 Phase Mux Preset} {Charge Pump Current} {Bandwidth Control}"
dict set ::pll_all_ip_params parameterTable_values "141 10 {1410.0 MHz} 6 4 1 1 1 1 1 1 1 false 71 70 true false 5 5 false false 3 2 256 256 256 256 256 1 1 3 2 256 256 256 256 256 1 1 false false false false false false false false false false false true true true true true true true 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 pll_cp_setting21 pll_bw_res_setting6"
dict set ::pll_all_ip_params mifTable_names "{The MIF file specified does not yet exist}"
dict set ::pll_all_ip_params pll_m_cnt_basic "1"
dict set ::pll_all_ip_params pll_m_cnt "1"
dict set ::pll_all_ip_params prot_mode "BASIC"
dict set ::pll_all_ip_params protocol_mode "PROTOCOL_MODE_BASIC"
dict set ::pll_all_ip_params m_cnt_hi_div "71"
dict set ::pll_all_ip_params eff_m_cnt "1"
dict set ::pll_all_ip_params multiply_factor "141"
dict set ::pll_all_ip_params use_core_refclk "false"
dict set ::pll_all_ip_params m_cnt_lo_div "70"
dict set ::pll_all_ip_params n_cnt_hi_div "5"
dict set ::pll_all_ip_params n_cnt_lo_div "5"
dict set ::pll_all_ip_params m_cnt_bypass_en "false"
dict set ::pll_all_ip_params n_cnt_bypass_en "false"
dict set ::pll_all_ip_params m_cnt_odd_div_duty_en "true"
dict set ::pll_all_ip_params n_cnt_odd_div_duty_en "false"
dict set ::pll_all_ip_params pll_vco_div "1"
dict set ::pll_all_ip_params pll_cp_current "pll_cp_setting21"
dict set ::pll_all_ip_params pll_bwctrl "pll_bw_res_setting6"
dict set ::pll_all_ip_params pll_fractional_division "1"
dict set ::pll_all_ip_params fractional_vco_multiplier "false"
dict set ::pll_all_ip_params reference_clock_frequency "100.0 MHz"
dict set ::pll_all_ip_params pll_fractional_cout "1"
dict set ::pll_all_ip_params pll_dsm_out_sel "1st_order"
dict set ::pll_all_ip_params operation_mode "direct"
dict set ::pll_all_ip_params number_of_clocks "2"
dict set ::pll_all_ip_params number_of_outclks "2"
dict set ::pll_all_ip_params pll_vcoph_div "1"
dict set ::pll_all_ip_params pll_type "Agilex 5"
dict set ::pll_all_ip_params pll_subtype "General"
dict set ::pll_all_ip_params pll_output_clk_frequency "1410.0 MHz"
dict set ::pll_all_ip_params pll_pfd_frequency "10.0 MHz"
dict set ::pll_all_ip_params mimic_fbclk_type "gclk"
dict set ::pll_all_ip_params pll_bw_sel "Low"
dict set ::pll_all_ip_params pll_slf_rst "false"
dict set ::pll_all_ip_params pll_fbclk_mux_1 "pll_fbclk_mux_1_glb"
dict set ::pll_all_ip_params pll_fbclk_mux_2 "pll_fbclk_mux_2_m_cnt"
dict set ::pll_all_ip_params pll_m_cnt_in_src "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params pll_clkin_0_src "clk_0"
dict set ::pll_all_ip_params refclk1_frequency "0 MHz"
dict set ::pll_all_ip_params pll_clk_loss_sw_en "false"
dict set ::pll_all_ip_params pll_manu_clk_sw_en "false"
dict set ::pll_all_ip_params pll_auto_clk_sw_en "false"
dict set ::pll_all_ip_params pll_clkin_1_src "clk_0"
dict set ::pll_all_ip_params pll_clk_sw_dly "0"
dict set ::pll_all_ip_params pll_extclk_0_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_extclk_1_cnt_src "pll_extclk_cnt_src_vss"
dict set ::pll_all_ip_params pll_lock_fltr_cfg "100"
dict set ::pll_all_ip_params pll_unlock_fltr_cfg "2"
dict set ::pll_all_ip_params lock_mode "low_lock_time"
dict set ::pll_all_ip_params clock_to_compensate "0"
dict set ::pll_all_ip_params clock_name_global "false"
dict set ::pll_all_ip_params pll_freqcal_en "true"
dict set ::pll_all_ip_params pll_defer_cal_user_mode "true"
dict set ::pll_all_ip_params dprio_interface_sel "3"
dict set ::pll_all_ip_params merging_permitted "false"
dict set ::pll_all_ip_params bandwidth_mode "BANDWIDTH_MODE_AUTO"
dict set ::pll_all_ip_params compensation_clk_source "COMPENSATION_CLK_SOURCE_UNUSED"
dict set ::pll_all_ip_params compensation_mode "COMPENSATION_MODE_DIRECT"
dict set ::pll_all_ip_params cascade_mode "CASCADE_MODE_STANDALONE"
dict set ::pll_all_ip_params fb_clk_delay "0"
dict set ::pll_all_ip_params fb_clk_fractional_div_den "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_num "1"
dict set ::pll_all_ip_params fb_clk_fractional_div_value "1"
dict set ::pll_all_ip_params fb_clk_m_div "0"
dict set ::pll_all_ip_params out_clk_cascading_source "OUT_CLK_CASCADING_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_0_source "OUT_CLK_EXTERNAL_0_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_external_1_source "OUT_CLK_EXTERNAL_1_SOURCE_UNUSED"
dict set ::pll_all_ip_params out_clk_periph_0_delay "0"
dict set ::pll_all_ip_params out_clk_periph_0_en "true"
dict set ::pll_all_ip_params out_clk_periph_1_delay "0"
dict set ::pll_all_ip_params out_clk_periph_1_en "true"
dict set ::pll_all_ip_params ref_clk_delay "0"
dict set ::pll_all_ip_params ref_clk_n_div "1"
dict set ::pll_all_ip_params set_dutycycle "SET_DUTYCYCLE_FRACTION"
dict set ::pll_all_ip_params set_fractional "SET_FRACTIONAL_FRACTION"
dict set ::pll_all_ip_params set_freq "SET_FREQ_DIVISION"
dict set ::pll_all_ip_params set_phase "SET_PHASE_NUM_SHIFTS"
dict set ::pll_all_ip_params pfd_clk_freq "100000000"
dict set ::pll_all_ip_params vco_clk_freq "1000000000"
dict set ::pll_all_ip_params c_cnt_hi_div0 "3"
dict set ::pll_all_ip_params c_cnt_hi_div1 "2"
dict set ::pll_all_ip_params c_cnt_hi_div2 "256"
dict set ::pll_all_ip_params c_cnt_hi_div3 "256"
dict set ::pll_all_ip_params c_cnt_hi_div4 "256"
dict set ::pll_all_ip_params c_cnt_hi_div5 "256"
dict set ::pll_all_ip_params c_cnt_hi_div6 "256"
dict set ::pll_all_ip_params c_cnt_hi_div7 "1"
dict set ::pll_all_ip_params c_cnt_hi_div8 "1"
dict set ::pll_all_ip_params c_cnt_hi_div9 "1"
dict set ::pll_all_ip_params c_cnt_hi_div10 "1"
dict set ::pll_all_ip_params c_cnt_hi_div11 "1"
dict set ::pll_all_ip_params c_cnt_hi_div12 "1"
dict set ::pll_all_ip_params c_cnt_hi_div13 "1"
dict set ::pll_all_ip_params c_cnt_hi_div14 "1"
dict set ::pll_all_ip_params c_cnt_hi_div15 "1"
dict set ::pll_all_ip_params c_cnt_hi_div16 "1"
dict set ::pll_all_ip_params c_cnt_hi_div17 "1"
dict set ::pll_all_ip_params c_cnt_lo_div0 "3"
dict set ::pll_all_ip_params c_cnt_lo_div1 "2"
dict set ::pll_all_ip_params c_cnt_lo_div2 "256"
dict set ::pll_all_ip_params c_cnt_lo_div3 "256"
dict set ::pll_all_ip_params c_cnt_lo_div4 "256"
dict set ::pll_all_ip_params c_cnt_lo_div5 "256"
dict set ::pll_all_ip_params c_cnt_lo_div6 "256"
dict set ::pll_all_ip_params c_cnt_lo_div7 "1"
dict set ::pll_all_ip_params c_cnt_lo_div8 "1"
dict set ::pll_all_ip_params c_cnt_lo_div9 "1"
dict set ::pll_all_ip_params c_cnt_lo_div10 "1"
dict set ::pll_all_ip_params c_cnt_lo_div11 "1"
dict set ::pll_all_ip_params c_cnt_lo_div12 "1"
dict set ::pll_all_ip_params c_cnt_lo_div13 "1"
dict set ::pll_all_ip_params c_cnt_lo_div14 "1"
dict set ::pll_all_ip_params c_cnt_lo_div15 "1"
dict set ::pll_all_ip_params c_cnt_lo_div16 "1"
dict set ::pll_all_ip_params c_cnt_lo_div17 "1"
dict set ::pll_all_ip_params c_cnt_prst0 "1"
dict set ::pll_all_ip_params c_cnt_prst1 "1"
dict set ::pll_all_ip_params c_cnt_prst2 "1"
dict set ::pll_all_ip_params c_cnt_prst3 "1"
dict set ::pll_all_ip_params c_cnt_prst4 "1"
dict set ::pll_all_ip_params c_cnt_prst5 "1"
dict set ::pll_all_ip_params c_cnt_prst6 "1"
dict set ::pll_all_ip_params c_cnt_prst7 "1"
dict set ::pll_all_ip_params c_cnt_prst8 "1"
dict set ::pll_all_ip_params c_cnt_prst9 "1"
dict set ::pll_all_ip_params c_cnt_prst10 "1"
dict set ::pll_all_ip_params c_cnt_prst11 "1"
dict set ::pll_all_ip_params c_cnt_prst12 "1"
dict set ::pll_all_ip_params c_cnt_prst13 "1"
dict set ::pll_all_ip_params c_cnt_prst14 "1"
dict set ::pll_all_ip_params c_cnt_prst15 "1"
dict set ::pll_all_ip_params c_cnt_prst16 "1"
dict set ::pll_all_ip_params c_cnt_prst17 "1"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst0 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst1 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst2 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst3 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst4 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst5 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst6 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst7 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst8 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst9 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst10 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst11 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst12 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst13 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst14 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst15 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst16 "0"
dict set ::pll_all_ip_params c_cnt_ph_mux_prst17 "0"
dict set ::pll_all_ip_params c_cnt_in_src0 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src1 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src2 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src3 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src4 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src5 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src6 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src7 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src8 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src9 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src10 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src11 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src12 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src13 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src14 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src15 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src16 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_in_src17 "c_m_cnt_in_src_ph_mux_clk"
dict set ::pll_all_ip_params c_cnt_bypass_en0 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en1 "false"
dict set ::pll_all_ip_params c_cnt_bypass_en2 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en3 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en4 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en5 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en6 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en7 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en8 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en9 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en10 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en11 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en12 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en13 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en14 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en15 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en16 "true"
dict set ::pll_all_ip_params c_cnt_bypass_en17 "true"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en0 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en1 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en2 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en3 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en4 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en5 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en6 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en7 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en8 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en9 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en10 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en11 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en12 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en13 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en14 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en15 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en16 "false"
dict set ::pll_all_ip_params c_cnt_odd_div_duty_en17 "false"
dict set ::pll_all_ip_params output_clock_frequency0 "235.0 MHz"
dict set ::pll_all_ip_params output_clock_frequency1 "352.5 MHz"
dict set ::pll_all_ip_params output_clock_frequency2 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency3 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency4 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency5 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency6 "0 ps"
dict set ::pll_all_ip_params output_clock_frequency7 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency8 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency9 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency10 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency11 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency12 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency13 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency14 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency15 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency16 "0 MHz"
dict set ::pll_all_ip_params output_clock_frequency17 "0 MHz"
dict set ::pll_all_ip_params phase_shift0 "0 ps"
dict set ::pll_all_ip_params phase_shift1 "0 ps"
dict set ::pll_all_ip_params phase_shift2 "0 ps"
dict set ::pll_all_ip_params phase_shift3 "0 ps"
dict set ::pll_all_ip_params phase_shift4 "0 ps"
dict set ::pll_all_ip_params phase_shift5 "0 ps"
dict set ::pll_all_ip_params phase_shift6 "0 ps"
dict set ::pll_all_ip_params phase_shift7 "0 ps"
dict set ::pll_all_ip_params phase_shift8 "0 ps"
dict set ::pll_all_ip_params phase_shift9 "0 ps"
dict set ::pll_all_ip_params phase_shift10 "0 ps"
dict set ::pll_all_ip_params phase_shift11 "0 ps"
dict set ::pll_all_ip_params phase_shift12 "0 ps"
dict set ::pll_all_ip_params phase_shift13 "0 ps"
dict set ::pll_all_ip_params phase_shift14 "0 ps"
dict set ::pll_all_ip_params phase_shift15 "0 ps"
dict set ::pll_all_ip_params phase_shift16 "0 ps"
dict set ::pll_all_ip_params phase_shift17 "0 ps"
dict set ::pll_all_ip_params duty_cycle0 "50"
dict set ::pll_all_ip_params duty_cycle1 "50"
dict set ::pll_all_ip_params duty_cycle2 "50"
dict set ::pll_all_ip_params duty_cycle3 "50"
dict set ::pll_all_ip_params duty_cycle4 "50"
dict set ::pll_all_ip_params duty_cycle5 "50"
dict set ::pll_all_ip_params duty_cycle6 "50"
dict set ::pll_all_ip_params duty_cycle7 "50"
dict set ::pll_all_ip_params duty_cycle8 "50"
dict set ::pll_all_ip_params duty_cycle9 "50"
dict set ::pll_all_ip_params duty_cycle10 "50"
dict set ::pll_all_ip_params duty_cycle11 "50"
dict set ::pll_all_ip_params duty_cycle12 "50"
dict set ::pll_all_ip_params duty_cycle13 "50"
dict set ::pll_all_ip_params duty_cycle14 "50"
dict set ::pll_all_ip_params duty_cycle15 "50"
dict set ::pll_all_ip_params duty_cycle16 "50"
dict set ::pll_all_ip_params duty_cycle17 "50"
dict set ::pll_all_ip_params clock_name_0 "outclk0"
dict set ::pll_all_ip_params clock_name_1 "outclk1"
dict set ::pll_all_ip_params clock_name_global_0 "false"
dict set ::pll_all_ip_params clock_name_global_1 "false"
dict set ::pll_all_ip_params clock_name_global_2 "false"
dict set ::pll_all_ip_params clock_name_global_3 "false"
dict set ::pll_all_ip_params clock_name_global_4 "false"
dict set ::pll_all_ip_params clock_name_global_5 "false"
dict set ::pll_all_ip_params clock_name_global_6 "false"
dict set ::pll_all_ip_params clock_name_global_7 "false"
dict set ::pll_all_ip_params clock_name_global_8 "false"
dict set ::pll_all_ip_params divide_factor0 "1"
dict set ::pll_all_ip_params divide_factor1 "1"
dict set ::pll_all_ip_params divide_factor2 "1"
dict set ::pll_all_ip_params divide_factor3 "1"
dict set ::pll_all_ip_params divide_factor4 "1"
dict set ::pll_all_ip_params divide_factor5 "1"
dict set ::pll_all_ip_params divide_factor6 "1"
dict set ::pll_all_ip_params divide_factor7 "1"
dict set ::pll_all_ip_params divide_factor8 "1"
dict set ::pll_all_ip_params out_clk_0_c_div "1"
dict set ::pll_all_ip_params out_clk_1_c_div "1"
dict set ::pll_all_ip_params out_clk_2_c_div "1"
dict set ::pll_all_ip_params out_clk_3_c_div "1"
dict set ::pll_all_ip_params out_clk_4_c_div "1"
dict set ::pll_all_ip_params out_clk_5_c_div "1"
dict set ::pll_all_ip_params out_clk_6_c_div "1"
dict set ::pll_all_ip_params out_clk_0_core_en "true"
dict set ::pll_all_ip_params out_clk_1_core_en "true"
dict set ::pll_all_ip_params out_clk_2_core_en "true"
dict set ::pll_all_ip_params out_clk_3_core_en "true"
dict set ::pll_all_ip_params out_clk_4_core_en "true"
dict set ::pll_all_ip_params out_clk_5_core_en "true"
dict set ::pll_all_ip_params out_clk_6_core_en "true"
dict set ::pll_all_ip_params out_clk_0_delay "0"
dict set ::pll_all_ip_params out_clk_1_delay "0"
dict set ::pll_all_ip_params out_clk_2_delay "0"
dict set ::pll_all_ip_params out_clk_3_delay "0"
dict set ::pll_all_ip_params out_clk_4_delay "0"
dict set ::pll_all_ip_params out_clk_5_delay "0"
dict set ::pll_all_ip_params out_clk_6_delay "0"
dict set ::pll_all_ip_params out_clk_0_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_1_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_2_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_3_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_4_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_5_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_6_dutycycle_den "2"
dict set ::pll_all_ip_params out_clk_0_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_1_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_2_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_3_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_4_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_5_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_6_dutycycle_num "1"
dict set ::pll_all_ip_params out_clk_0_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_1_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_2_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_3_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_4_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_5_phase_shifts "0"
dict set ::pll_all_ip_params out_clk_6_phase_shifts "0"
dict set ::pll_all_ip_params ref_clk_0_freq "100000000"
dict set ::pll_all_ip_params ref_clk_1_freq "100000000"
dict set ::pll_all_ip_params out_clk_0_freq "1000000000"
dict set ::pll_all_ip_params out_clk_1_freq "1000000000"
dict set ::pll_all_ip_params out_clk_2_freq "1000000000"
dict set ::pll_all_ip_params out_clk_3_freq "1000000000"
dict set ::pll_all_ip_params out_clk_4_freq "1000000000"
dict set ::pll_all_ip_params out_clk_5_freq "1000000000"
dict set ::pll_all_ip_params out_clk_6_freq "1000000000"
dict set ::pll_all_ip_params out_clk_0_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_1_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_2_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_3_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_4_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_5_phase_ps "1000000000"
dict set ::pll_all_ip_params out_clk_6_phase_ps "1000000000"
dict set ::pll_all_ip_params pll_tclk_mux_en "false"
dict set ::pll_all_ip_params pll_tclk_sel "pll_tclk_m_src"
dict set ::pll_all_ip_params pll_vco_freq_band_0 "pll_freq_clk0_band18"
dict set ::pll_all_ip_params pll_vco_freq_band_1 "pll_freq_clk1_band18"
dict set ::pll_all_ip_params pll_freqcal_req_flag "true"
dict set ::pll_all_ip_params cal_converge "false"
dict set ::pll_all_ip_params cal_error "cal_clean"
dict set ::pll_all_ip_params pll_cal_done "false"
dict set ::pll_all_ip_params include_iossm "false"
dict set ::pll_all_ip_params cal_code_hex_file "iossm.hex"
dict set ::pll_all_ip_params parameter_table_hex_file "seq_params_sim.hex"
dict set ::pll_all_ip_params iossm_nios_sim_clk_period_ps "1333"
dict set ::pll_all_ip_params hp_number_of_family_allowable_clocks "9"
dict set ::pll_all_ip_params hp_previous_num_clocks "1"
dict set ::pll_all_ip_params hp_actual_vco_frequency_fp "1410.0"
dict set ::pll_all_ip_params hp_qsys_scripting_mode "true"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp0 "235.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp1 "352.5"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp2 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp3 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp4 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp5 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp6 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp7 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp8 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp9 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp10 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp11 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp12 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp13 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp14 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp15 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp16 "100.0"
dict set ::pll_all_ip_params hp_actual_output_clock_frequency_fp17 "100.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp0 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp1 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp2 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp3 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp4 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp5 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp6 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp7 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp8 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp9 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp10 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp11 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp12 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp13 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp14 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp15 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp16 "0.0"
dict set ::pll_all_ip_params hp_actual_phase_shift_fp17 "0.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp0 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp1 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp2 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp3 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp4 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp5 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp6 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp7 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp8 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp9 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp10 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp11 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp12 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp13 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp14 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp15 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp16 "50.0"
dict set ::pll_all_ip_params hp_actual_duty_cycle_fp17 "50.0"
 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 14 pcie_ed_iopll0 17 altera_iopll_1931 5 synth 55 pcie_ed_iopll0_altera_iopll_1931_klgmlua_parameters.tcl 7550 # PLL Parameters

#USER W A R N I N G !
#USER The PLL parameters are statically defined in this
#USER file at generation time!
#USER To ensure timing constraints and timing reports are correct, when you make 
#USER any changes to the PLL component using the Qsys,
#USER apply those changes to the PLL parameters in this file

set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename pcie_ed_iopll0_altera_iopll_1931_klgmlua

set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data [dict create]
set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data [dict create]
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk pattern __inst_name__|tennm_ph2_iopll|ref_clk0
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk node_type pin
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk pin_id ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk pin_node_name ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk port_id ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk port_node_name ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk is_fpga_pin false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk is_main_refclk true
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk exists false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk name "__inst_name___refclk"
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk period 10.000
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data refclk half_period 5.000
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock pattern __inst_name__|tennm_ph2_iopll~ncntr_reg
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock node_type register
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock pin_id ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock is_valid false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock exists false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock name "__inst_name___n_cnt_clk"
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock src refclk
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock master ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock multiply_by 1
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock divide_by 10
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock phase 0.000
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data n_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock pattern __inst_name__|tennm_ph2_iopll~mcntr_reg
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock node_type register
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock pin_id ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock pin_node_name ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock is_valid false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock exists false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock name "__inst_name___m_cnt_clk"
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock src refclk
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock master ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock multiply_by 1
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock divide_by 1410
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock phase 0.000
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data m_cnt_clock duty_cycle 50
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 pattern __inst_name__|tennm_ph2_iopll|out_clk\[0\]
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 node_type pin
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 pin_id ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 pin_node_name ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 is_valid false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 exists false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 name __inst_name___outclk0
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 src refclk
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 master ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 multiply_by 141
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 divide_by 6
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 phase 0.000
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 duty_cycle 50
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk0 counter_index 0
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 pattern __inst_name__|tennm_ph2_iopll|out_clk\[1\]
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 node_type pin
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 pin_id ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 pin_node_name ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 is_valid false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 exists false
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 name __inst_name___outclk1
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 src refclk
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 master ""
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 multiply_by 141
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 divide_by 4
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 phase 0.000
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 duty_cycle 50
dict set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data outclk1 counter_index 1
 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 14 pcie_ed_iopll0 17 altera_iopll_1931 5 synth 52 pcie_ed_iopll0_altera_iopll_1931_klgmlua_pin_map.tcl 46747 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#####################################################################
#
# THIS IS AN AUTO-GENERATED FILE!
# -------------------------------
# If you modify this files, all your changes will be lost if you
# regenerate the core!
#
# FILE DESCRIPTION
# ----------------
# This file contains the traversal routines that are used by
# pcie_ed_iopll0_altera_iopll_1931_klgmlua.sdc scripts. 
#
# These routines are only meant to support the SDC. 
# Trying to using them in a different context can have unexpected 
# results.

set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_debug 0

set script_dir [file dirname [info script]]

source [file join $script_dir pcie_ed_iopll0_altera_iopll_1931_klgmlua_parameters.tcl]

proc get_warnings_disabled {} {
    set local_disable_warnings true
    set inis [split [get_global_assignment -name INI_VARS] ";"]
    foreach ini $inis {
        set ini_lst [split $ini "="]
        lassign $ini_lst ini_name ini_value
        if {$ini_name == "disable_warnings" && $ini_value == "off"} {
            set local_disable_warnings false
            break
        }
    }
    return $local_disable_warnings 
}
set ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_disable_warnings [get_warnings_disabled]

proc ai_get_timequest_name { full_hier_name } {
    # Input: lib1:inst1|lib2:inst2|lib3:inst3
    # Output: inst1|inst2|inst3
    set tq_name ""
    set tq_name_list {}
    set lib_inst_pair_list [split $full_hier_name "|"]

    foreach i_lib_inst_pair_str $lib_inst_pair_list {
        set i_lib_inst_pair [split $i_lib_inst_pair_str ":"]

        if {[llength $i_lib_inst_pair] > 1} {
            # take the 2nd element and onwards
            lappend tq_name_list [join [lrange $i_lib_inst_pair 1 end] :]
        } else {
            # if there is only 1 element, probably the last hierarchy which is a port or something like that.
            lappend tq_name_list [lindex $i_lib_inst_pair end]
        }
    }

    set tq_name [join $tq_name_list "|"]
    return $tq_name
}

# ----------------------------------------------------------------
#
proc ai_post_message {msg_type msg {msg_context sta_only}} {
#
# Description: Posts a message to Quartus, depending on 
# msg_context (sta_only, all)
#              
#              
#
# ----------------------------------------------------------------

    if {$msg_type == "debug"} {
        if {$::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_debug} {
            puts $msg
        }
    } else {
        if {$msg_context == "all"} {
            post_message -type $msg_type $msg
        } elseif {$msg_context == "sta_only"} {
            if {$::TimeQuestInfo(nameofexecutable) == "quartus_sta"} {
                post_message -type $msg_type $msg
            }
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_are_entity_names_on { } {
#
# Description: Determines if the entity names option is on
#
# ----------------------------------------------------------------
	return [set_project_mode -is_show_entity]	
}

# ----------------------------------------------------------------
#
proc ai_initialize_pll_db { pll_db_par } {
#
# Description: Gets the instances of this particular PLL IP and creates the pin
#              cache
#
# ----------------------------------------------------------------
	upvar $pll_db_par local_pll_db

	global ::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename

	ai_post_message info "Initializing PLL database for CORE $::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename"
	set instance_list [ai_get_core_instance_list $::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename]

	foreach instname $instance_list {
		ai_post_message info "Finding port-to-pin mapping for CORE: $::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename INSTANCE: $instname"

        # Some PLL atoms get merged and are no longer present
        if { [ai_get_pll_atom $instname] eq "" } { continue }

		set clock_data_dicts [ai_get_pll_pins $instname]
		lassign $clock_data_dicts base_clock_data_dict gen_clock_data_dict
        print_clock_data $base_clock_data_dict
        print_clock_data $gen_clock_data_dict 

		set local_pll_db($instname) $clock_data_dicts 
	}
}

# ----------------------------------------------------------------
#
proc ai_get_core_instance_list {corename} {
#
# Description: Converts node names from one style to another style
#
# ----------------------------------------------------------------
	set full_instance_list [ai_get_core_full_instance_list $corename]
	set instance_list [list]

	foreach inst $full_instance_list {
		if {[lsearch $instance_list [escape_brackets $inst]] == -1} {
            ai_post_message debug "Found instance:  $inst"
			lappend instance_list $inst
		}
	}
	return $instance_list
}

# ----------------------------------------------------------------
#
proc ai_get_core_full_instance_list {corename} {
#
# Description: Finds the instances of the particular IP by searching through the cells
#
# ----------------------------------------------------------------
    set instance_list [list]

    set instance_list_pre [design::get_instances -entity $corename]

    foreach instance $instance_list_pre {
        lappend instance_list [ai_get_timequest_name $instance]
    }

	if {[ llength $instance_list ] == 0} {

        if {!$::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_disable_warnings} {
            ai_post_message warning "The auto-constraining script was not able to detect any instance for core < $corename >" all
            ai_post_message warning "Verify the following:"
            ai_post_message warning " The core < $corename > is instantiated within another component (wrapper)" all
            ai_post_message warning " The core is not the top-level of the project" all
        }
	}

	return $instance_list
}
proc ai_get_registers {pattern} {
    if {$::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_disable_warnings} {
        return [get_registers -nowarn -no_duplicates $pattern]
    } else {
        return [get_registers -no_duplicates $pattern]
    }
}
proc ai_get_pins {pattern} {
    if {$::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_corename_disable_warnings} {
        return [get_pins -nowarn -no_duplicates $pattern]
    } else {
        return [get_pins -no_duplicates $pattern]
    }
}
proc ai_get_pin_node_name {pattern} {
    set pin_collection [ai_get_pins $pattern]
    set num_pins [get_collection_size $pin_collection]
    if {$num_pins == 1} {
        foreach_in_collection id $pin_collection {
            set node_name [get_node_info -name $id]	     
            return $node_name
        }
    } 
    return ""
 
}

# ----------------------------------------------------------------
#
proc ai_get_collection_size_from_pattern {pattern} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    set pin_collection [get_pins -no_duplicates $pattern]
    return [get_collection_size $pin_collection]
}

# ----------------------------------------------------------------
#
proc print_clock_data {d} {
#
# Description: Prints clock data dict
#
# ---------------------------------------------------------------- 
    dict for {clock_key info} $d {
        ai_post_message debug "Clock:  $clock_key"
        dict for {key val} $info {
            ai_post_message debug "   $key: $val"
        }
    }
}

# ----------------------------------------------------------------
#
proc ai_subst_instname {clock_data_dict patt} {
#
# Description: Takes a string regex and gets the pin collection.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            regsub -all "__inst_name__" $name $patt new_name
            regsub -all "__inst_name__" $pattern $patt new_pattern
            
            dict set clock_data_dict $clock_key name $new_name
            dict set clock_data_dict $clock_key pattern $new_pattern
            
            if {[dict exists $clock_data_dict $clock_key "through_pin" ]} {
                regsub -all "__inst_name__" $through_pin $patt new_through_pin
                dict set clock_data_dict $clock_key through_pin $new_through_pin
            }
        }
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_update_genclk_div_mult {clock_data_dict pll_parameters_dict} {
#
# Description: Updates the dict with div/mult values collected from
# the PLL's atom parameters.
#
# ----------------------------------------------------------------
    set compensated_counter_div 0
    set clock_to_compensate [dict get $pll_parameters_dict clock_to_compensate]
    # Loop over dict to find the compensated counter's div value first.
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {[info exists counter_index]} { 
                set clk_string_length [string length $clock_to_compensate]
                set clock_to_compensate_index [string index $clock_to_compensate [expr {$clk_string_length - 1}] ]
                if {$counter_index == $clock_to_compensate_index} {
                    set compensated_counter_div [dict get $pll_parameters_dict c${counter_index}_total]
                }
            }
        }
        unset -nocomplain counter_index
    }
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Getting div/mult factors for clock $clock_key" 
            set ccnt -1
            if {[info exists counter_index]} {
                set ccnt [dict get $pll_parameters_dict c${counter_index}_total]
			    set ccnt_dc [dict get $pll_parameters_dict duty_cycle${counter_index}]
            } else {
                set counter_index -1
			    set ccnt_dc 50
            }
            set mult_div [ai_get_mult_div_factors \
                $clock_key \
                $src \
                [dict get $pll_parameters_dict n_total] \
                [dict get $pll_parameters_dict m_total] \
                $ccnt \
                $counter_index \
                $compensated_counter_div \
                [dict get $pll_parameters_dict compensation_mode] \
                [dict get $pll_parameters_dict clock_to_compensate]]

            lassign $mult_div mult div

            ai_post_message debug "Setting mult_div factors for: $clock_key to $mult/$div"

            dict set clock_data_dict $clock_key multiply_by $mult
            dict set clock_data_dict $clock_key divide_by $div
            dict set clock_data_dict $clock_key duty_cycle $ccnt_dc
        }
        unset -nocomplain counter_index
    }
    return $clock_data_dict
}
# ----------------------------------------------------------------
#
proc ai_set_genclk_pin_info {clock_data_dict} {
#
# Description: Updates the dict with pin info collected from making
# STA API calls.
#
# ----------------------------------------------------------------
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            if {$node_type == "register"} {
                set pin_collection [ai_get_registers $pattern]
            } elseif {$node_type == "pin"} {
                set pin_collection [ai_get_pins $pattern]
            } else {
                ai_post_message "debug" "Incorrect type of node."
            }
            set num_pins [get_collection_size $pin_collection]
            if {$num_pins == 1} {
                # Always set valid to true if we found the pin node
                ai_post_message debug "Setting clock as valid."
                dict set clock_data_dict $clock_key is_valid true
                
                # This for loop should only loop once.
                foreach_in_collection id $pin_collection {
                    set node_name [get_node_info -name $id]	     
                    dict set clock_data_dict $clock_key pin_id $id
                    dict set clock_data_dict $clock_key pin_node_name $node_name
                }
                # Check if clock_exists, if it does, then
                # set key "exists" on the clock info dict.
                dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

            
            } else {
                dict set clock_data_dict $clock_key is_valid false
            }

        }
    }
    return $clock_data_dict
    
    
} 
# ----------------------------------------------------------------
#
proc ai_set_baseclk_pin_info {clock_data_dict refclk_data_dict} {
#
    # Description: Updates the dict with pin info collected from refclk data
    # dict, which was obtained by traversing netlist.
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_set_baseclk_pin_info"

    dict for {clock_key info} $clock_data_dict {
        dict with info {
            ai_post_message debug "Setting pin info for clock $clock_key"
            
            # For each clock in refclk dict, find the one whose pin name
            # matches the pattern in baseclk dict. WE need to do this since
            # we dont find refclk nodes with patterns, but rather by traversal
            # of netlist from outclk backwards.
            
            set node_name ""
            dict for {clock_id info} $refclk_data_dict {
                dict with info {
                    ai_post_message debug "Comparing pattern $pattern with refclock: $ref_pin_node_name"
                    if {[string equal -nocase $pattern $ref_pin_node_name]} {
                        dict set clock_data_dict $clock_key pin_id $ref_pin_id
                        dict set clock_data_dict $clock_key pin_node_name $ref_pin_node_name
                        dict set clock_data_dict $clock_key port_id $ref_port_id
                        dict set clock_data_dict $clock_key port_node_name $ref_port_node_name
                        dict set clock_data_dict $clock_key is_fpga_pin $ref_is_fpga_pin
                        set node_name $ref_port_node_name
                        break
                    }
                }
            }
            # Check if clock_exists, if it does, then
            # set key "exists" on the clock info dict.
            dict set clock_data_dict $clock_key exists [ai_clock_exists $node_name]

        }
    }
    return $clock_data_dict
    
}
proc ai_get_n_cnt_clock_node_name {gen_clock_data_dict} {
    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Clock:  $clock_key, pin_node_name: $pin_node_name"

            if {$clock_key == "n_cnt_clock"} {
                return $pin_node_name
            }
        }
    }
    return ""
}

# ----------------------------------------------------------------
#
proc ai_update_baseclk_data {base_clock_data_dict pll_parameters_dict} {
#
    # Description: Updates the refclk information based on atom settings
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_baseclk_data_dict"
    set mode [dict get $pll_parameters_dict prot_mode]

    dict for {base_clock_key info} $base_clock_data_dict {
        dict with info {
            if {$is_main_refclk} {
                set ref_period [dict get $pll_parameters_dict refclk_period]
                if {[string match "*UIB" $mode]} {
                    set ref_period [expr ceil($ref_period * 1000.0)/1000.0]
                } else {
                    set ref_period [expr round($ref_period * 1000.0)/1000.0] 
                }
                set ref_period [format %.3f $ref_period]
                dict set base_clock_data_dict $base_clock_key period $ref_period

                set half_period [expr $ref_period /2]
                if {[string match "*UIB" $mode]} {
                    set half_period [expr ceil($half_period * 1000.0)/1000.0] 
                } else {
                    set half_period [expr round($half_period * 1000.0)/1000.0] 
                }
                set half_period [format %.3f $half_period]
                dict set base_clock_data_dict $base_clock_key half_period $half_period

            }
        }
    }

    return $base_clock_data_dict
}

# ----------------------------------------------------------------
#
proc ai_update_genclk_sources {base_clock_data_dict gen_clock_data_dict pll_parameters_dict} {
#
# Description: Updates the genclk data dict with src nodes from the appropriate
#              refclks
#
# ----------------------------------------------------------------
    ai_post_message debug "In ai_update_genclk_sources"

    # Set it to either refclk or n_cnt_clock
    # Don't use vcoph anymore (HSD 14017082319)

    dict for {clock_key info} $gen_clock_data_dict {
        dict with info {
            ai_post_message debug "Setting src pin info for clock $clock_key"

            set node_name ""
            set main_refclk_key ""
            dict for {base_clock_key base_clock_data_dict_info} $base_clock_data_dict {
                dict with base_clock_data_dict_info {
                    if {$is_main_refclk} {
                        set main_refclk_key $base_clock_key
                        if {$is_fpga_pin} {
                            set node_name $port_node_name
                        } else {
                            set node_name $pin_node_name
                        }
                        break
                    }
                }
            }
            if {$clock_key != "n_cnt_clock" && ![dict get $pll_parameters_dict n_bypass]} {
                set src "n_cnt_clock"
            }
            if {$src == "refclk" || $src == "cascade_in"} {
                set src_ $node_name
            } elseif {$src == "n_cnt_clock"} {
                if {[is_post_syn_sta]} {
                    set gen_clock_data_dict_for_post_syn $gen_clock_data_dict
                    dict for {clk_key gen_clock_data_dict_for_post_syn_info} $gen_clock_data_dict_for_post_syn {
                        if {$clk_key == "n_cnt_clock"} {
                            dict set gen_clock_data_dict $clock_key master [dict get $gen_clock_data_dict_for_post_syn_info name]
                        }
                    }
                } else {
                    set src_ [ai_get_n_cnt_clock_node_name $gen_clock_data_dict]
                }
            } else {
                set src_ ""
                ai_post_message "warning" "Undefined clock source: $src"
                dict set gen_clock_data_dict $clock_key is_valid false
            }

            dict set gen_clock_data_dict $clock_key src $src_
        }
    }
    return $gen_clock_data_dict
}
proc ai_invalidate_clocks {clock_data_dict} {
    # Set the is_valid flag on each clock to false
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            dict set clock_data_dict $clock_key is_valid false
        }
    }
    return $clock_data_dict
}
proc ai_get_first_outclk_node {clock_data_dict} {
    set outclk_pin_id "None"
    dict for {clock_key info} $clock_data_dict {
        dict with info {
            if {$node_type == "pin" && $is_valid} {
                set outclk_pin_id $pin_id
                break
            }
        }
    }
    if {$outclk_pin_id == "None"} {
        ai_post_message "warning" "Could not find any valid outclks"
    }
    return $outclk_pin_id 
}
# ----------------------------------------------------------------
#
proc ai_get_pll_pins { instname } {
#
# Description: Stores the pins of interest for the instance of the IP
#
# ----------------------------------------------------------------

    set base_clock_data_dict $::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_base_clock_data
    set gen_clock_data_dict $::GLOBAL_top_pcie_ed_iopll0_altera_iopll_1931_klgmlua_gen_clock_data
    # First regsub the instance name for the pin names and patterns.
    set base_clock_data_dict [ai_subst_instname $base_clock_data_dict $instname]
    set gen_clock_data_dict [ai_subst_instname $gen_clock_data_dict $instname]


    set pll_parameters_dict [ai_get_pll_atom_parameters $instname] 
    set gen_clock_data_dict [ai_set_genclk_pin_info $gen_clock_data_dict]

    ai_post_message debug "gen_clock_data_dict initial: "
    print_clock_data $gen_clock_data_dict 
    
    # Traverse the first generated clock back to find FPGA pins for refclks.
    set outclk_node_id [ai_get_first_outclk_node $gen_clock_data_dict]
    if {$outclk_node_id != "None"} {
        set refclk_data_dict [ai_get_input_clk_info $outclk_node_id]
        ai_post_message debug "refclk_data_dict: "
        print_clock_data $refclk_data_dict

        set base_clock_data_dict [ai_set_baseclk_pin_info $base_clock_data_dict $refclk_data_dict]
        set gen_clock_data_dict [ai_update_genclk_sources $base_clock_data_dict $gen_clock_data_dict $pll_parameters_dict]
        set gen_clock_data_dict [ai_update_genclk_div_mult $gen_clock_data_dict $pll_parameters_dict] 
        set base_clock_data_dict [ai_update_baseclk_data $base_clock_data_dict $pll_parameters_dict] 
        ai_post_message debug "base_clock_data_dict: "
        print_clock_data $base_clock_data_dict 
        ai_post_message debug "gen_clock_data_dict final: "
        print_clock_data $gen_clock_data_dict
    } else {
        # Make sure that we don't create any clock constraints
        # if no output clock was found
        set gen_clock_data_dict [ai_invalidate_clocks $gen_clock_data_dict]
    }
    
    return [list $base_clock_data_dict $gen_clock_data_dict]
    
}

# ----------------------------------------------------------------
#
proc ai_get_input_clk_info { outclk_pin_id } {
#
# Description: Searches back from the output of the PLL to find the reference clock pin.
#              If the reference clock is fed by an input buffer, it finds that pin, otherwise
#              in cascading modes it will return the immediate reference clock input of the PLL.
#
# ----------------------------------------------------------------
	if {[ai_is_node_type_pll_clk $outclk_pin_id]} {
        #stores the refclk pin ids that were found by tracing the 
        #output clocks back up
		array set refclk_array [list]
		ai_traverse_fanin_up_to_depth $outclk_pin_id ai_is_node_type_pll_inclk clock refclk_array 20
        array set refclk_info_array [list]
        foreach {net_id id} [array get refclk_array] {
            set net_name [get_node_info -name $net_id]
            set refclk_info_array($net_id) $net_name

        }
        # Dict to hold the refclk info found by traversing the netlist back.
        # refclk_data = {
        #   clock_id = {
        #       ref_pin_id: str,
        #       ref_pin_node_name: str,
        #       ref_port_id: str,
        #       ref_port_node_name: str,
        #       ref_is_fpga_pin: true/false,
        #   }
        # }
        set refclk_data [dict create]
        
        set clock_id 0

        #only works if there is either 1 or 2 refclks
		if {[array size refclk_array] == 1 || [array size refclk_array] == 2} {
            #iterate over each refclk pin and trace back to find its input port
            foreach refclk_pin_id [array names refclk_info_array] {
                array set user_refclk_array [list]
                array unset refclk_array
                array unset user_refclk_array [list]
					 
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_user_clock clock user_refclk_array 10
                ai_traverse_fanin_up_to_depth $refclk_pin_id ai_is_node_type_pin clock refclk_array 10
					 
                # If fed by any user specified clock (which could be specified at the pin level or at the
                # buffer level), then use that pin as the source.
                # Otherwise, trace back to the dedicated input pin (depth 10 so that we don't include global clocks)
                if {[array size user_refclk_array] == 1 || [array size refclk_array] < 1} {
                    # Fed by a user specified clock, a global clock etc. 
                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id ""
                    dict set refclk_data $clock_id ref_port_node_name ""
                    dict set refclk_data $clock_id ref_is_fpga_pin false
                } else {
                    # Fed by a dedicated input pin
                    set port_id_ [lindex [array names refclk_array] 0]

                    dict set refclk_data $clock_id ref_pin_id $refclk_pin_id 
                    dict set refclk_data $clock_id ref_pin_node_name $refclk_info_array($refclk_pin_id)
                    dict set refclk_data $clock_id ref_port_id $port_id_
                    dict set refclk_data $clock_id ref_port_node_name [get_node_info -name $port_id_]
                    dict set refclk_data $clock_id ref_is_fpga_pin true
                }

                incr clock_id
            }
        } else {
			ai_post_message critical_warning "Could not find PLL ref clock that feeds [get_node_info -name $outclk_pin_id]" all
		}
	} else {
		ai_post_message error "Internal error: ai_get_input_clk_info only works for PLL output clocks" all
	}
	return $refclk_data
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pin { node_id } {
#
# Description: Determines if a node is a top-level port of the FPGA
#
# ----------------------------------------------------------------

	set node_type [get_node_info -type $node_id]
	if {$node_type == "port"} {
		set result 1
	} else {
		set result 0
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_user_clock { node_id } {
#
# Description: Determines if a node is a user-defined clock
#
# ----------------------------------------------------------------
    set node_name [get_node_info -name $node_id]	 
   
    if {[ai_clock_exists $node_name]} {
        return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_clk { node_id } {
#
# Description: Determines if a node is an output of a PLL
#
# ----------------------------------------------------------------

	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
            ai_post_message debug "Node_name: $node_name"
			if {[string match "*fourteennm_pll\|outclk\\\[*\\\]" $node_name] || [string match "*tennm_pll\|outclk\\\[*\\\]" $node_name] || [string match "*tennm_ph2_iopll\|out_clk\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll~ncntr_reg" $node_name] || [string match "*tennm_pll~ncntr_reg" $node_name] || [string match "*tennm_ph2_iopll~ncntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~c*cntr_reg" $node_name] || [string match "*tennm_pll~c*cntr_reg" $node_name] || [string match "*tennm_ph2_iopll~c*cntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll~mcntr_reg" $node_name] || [string match "*tennm_pll~mcntr_reg" $node_name] || [string match "*tennm_ph2_iopll~mcntr_reg" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|lvds_clk\\\[*\\\]" $node_name] || [string match "*tennm_pll\|lvds_clk\\\[*\\\]" $node_name]} {
				set result 1				
			} elseif {[string match "*fourteennm_pll\|loaden\\\[*\\\]" $node_name] || [string match "*tennm_pll\|loaden\\\[*\\\]" $node_name]} {
				set result 1
            } elseif {[string match "*tennm_ph2_iopll\|out_clk_periph0" $node_name]} {
				set result 1
			} elseif {[string match "*tennm_ph2_iopll\|out_clk_periph1" $node_name]} {
				set result 1
			} elseif {[string match "*tennm_ph2_iopll\|vco_clk_periph" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|vcoph\\\[*\\\]" $node_name] || [string match "*tennm_pll\|vcoph\\\[*\\\]" $node_name] || [string match "*tennm_ph2_iopll\|vco_clk\\\[*\\\]" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|pll_cascade_out" $node_name] || [string match "*tennm_pll\|pll_cascade_out" $node_name] || [string match "*tennm_ph2_iopll\|out_clk_cascade" $node_name]} {
				set result 1
			} elseif {[string match "*fourteennm_pll\|extclk_output\\\[*\\\]" $node_name] || [string match "*tennm_pll\|extclk_output\\\[*\\\]" $node_name] || [string match "*tennm_ph2_iopll\|out_clk_external*" $node_name]} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# ----------------------------------------------------------------
#
proc ai_is_node_type_pll_inclk { node_id } {
#
# Description: Determines if a node is an input of a PLL
#
# ----------------------------------------------------------------


	set cell_id [get_node_info -cell $node_id]
	
	if {$cell_id == ""} {
		set result 0
	} else {
		set atom_type [get_cell_info -atom_type $cell_id]
		if {$atom_type == "IOPLL"} {
			set node_name [get_node_info -name $node_id]
			set fanin_edges [get_node_info -clock_edges $node_id]
            if {([string match "*|refclk\\\[*\\\]" $node_name] || [string match "*|ref_clk0" $node_name] || [string match "*|ref_clk1" $node_name])  && [llength $fanin_edges] > 0} {
				set result 1
            } elseif {([string match "*|pll_cascade_in" $node_name]) && [llength $fanin_edges] > 0} {
				set result 1
			} else {
				set result 0
			}
		} else {
			set result 0
		}
	}
	return $result
}

# -----------------------------------------------------------------
#
proc ai_find_pll_inclk { match_command edge_type } {
#
# Desciption: Finds the pll inclk pin whose name matches the
#             match_command. Returns the inclk pin name if such
#             a pin is found, and returns "" if it is not found
#
# -----------------------------------------------------------------

    set fanin_id ""
    foreach_in_collection pin [get_pins $match_command] {
        if {[llength [get_node_info -${edge_type}_edges $pin]] > 0} {
            set fanin_id $pin
            break
        }
    }
    return $fanin_id
}

# ----------------------------------------------------------------
#
proc ai_traverse_fanin_up_to_depth { node_id match_command edge_type results_array_name depth} {
#
# Description: General traversal function up until a depth.  Use a function pointer to decide
#              ending conditions.
#
# ----------------------------------------------------------------

	upvar 1 $results_array_name results

	if {$depth < 0} {
		error "Internal error: Bad timing netlist search depth"
	}

	ai_post_message debug "\[ai_traverse_fanin_up_to_depth\] called with node_id: $node_id cmd: \"$match_command\" type: $edge_type node: [get_node_info -name $node_id]"
	if {[is_post_syn_sta] && $match_command == "ai_is_node_type_pll_inclk"} {
		set atom_name [get_cell_info -name [get_node_info -cell $node_id]]
        set fanin_id [ai_find_pll_inclk $atom_name|core*refclk* $edge_type]
        if {$fanin_id == ""} {
            set fanin_id [ai_find_pll_inclk $atom_name|pll*cascade*in* $edge_type]
        }
        if {$fanin_id == ""} {
            set fanin_id [ai_find_pll_inclk $atom_name|ref*clk* $edge_type]
        }
		set results($fanin_id) 1
		ai_post_message debug "\[ai_traverse_fanin_up_to_depth\] post syn model returning fanin id: [get_node_info -name $fanin_id]"
		return
	}

	set fanin_edges [get_node_info -${edge_type}_edges $node_id]
	set number_of_fanin_edges [llength $fanin_edges]
	for {set i 0} {$i != $number_of_fanin_edges} {incr i} {
		set fanin_edge [lindex $fanin_edges $i]
		set fanin_id [get_edge_info -src $fanin_edge]
		if {$match_command == "" || [eval $match_command $fanin_id] != 0} {
			set results($fanin_id) 1
		} elseif {$depth == 0} {
		} else {
			ai_traverse_fanin_up_to_depth $fanin_id $match_command $edge_type results [expr {$depth - 1}]
		}
	}
}

# ----------------------------------------------------------------
#
proc ai_index_in_collection { col j } {
#
# Description: Returns a particular index in a collection.
#              Analagous to lindex for lists.
#
# ----------------------------------------------------------------

	set i 0
	foreach_in_collection path $col {
		if {$i == $j} {
			return $path
		}
		set i [expr $i + 1]
	}
	return ""
}

#
# Description: Rounds a given floating point number
#              to 3 decimal places
#
# ----------------------------------------------------------------
proc ai_round_3dp { x } {
    return [expr { round($x * 1000) / 1000.0  } ]
}

# ----------------------------------------------------------------
# Description: Checks whether a given clock already exists 
# ----------------------------------------------------------------
proc ai_clock_exists { clock_name } {
    set clock_found false
    set input_clocks_col [get_clocks -nowarn]
    set num_input_clocks [get_collection_size $input_clocks_col]
    
    if {$num_input_clocks > 0} {
        foreach_in_collection iclk $input_clocks_col {
            if {![is_clock_defined $iclk]} {
                continue
            }

            set clk_targets_col [get_clock_info -target $iclk]
            set num_clk_targets [get_collection_size $clk_targets_col]
            if {$num_clk_targets > 0} {
                foreach_in_collection itgt $clk_targets_col {
                    set node_name [get_node_info -name $itgt]
                    if {[string compare $node_name $clock_name] == 0} {
                        set clock_found true
                        break
                    }
                }
            }
            if {$clock_found == true} {
                break;
            }
        }
    }

   return $clock_found 
}

proc ai_get_pll_atom {instname} {
    foreach_in_collection node [get_atom_nodes -type IOPLL] {
        set name [ai_get_timequest_name [get_atom_node_info -key NAME -node $node]]
        set node_list($name) $node

        if {[string first $instname $name] > -1} {
            return $node
        }
    }
    set sdc_file_name [info script]
    ai_post_message warning "Could not find IOPLL atom with the name <$instname> while processing <$sdc_file_name>. Please check the synthesis report to ensure that the IOPLL was not synthesized away." all
}
proc ai_get_mult_div_factors {clock_key src ncnt mcnt ccnt counter_index \
                              compensated_counter_div compensation_mode \
                              clock_to_compensate} {
    if {$clock_key == "vcoph" || $clock_key == "vcoph_periph"} {
        set clock_mult $mcnt
        set clock_div 1
    } elseif {$clock_key == "n_cnt_clock"} {
        set clock_mult 1
        set clock_div $ncnt
    } elseif {$clock_key == "m_cnt_clock"} {
        set clock_mult 1
        set clock_div [expr {$mcnt * $ncnt}]
    } else {

        if {[string first "vcoph" $src] > -1} {
            set clock_mult 1
            set clock_div $ccnt
        } else {
            # Handle NDFB mode. 
            # The equation for counter which is to be compensated: C_k = M / N
            # The equation for all other counters:                 C_!k = (M * C_k) / (N * C_!k)
            if {$compensation_mode == "COMPENSATION_MODE_NON_DEDICATED_SOURCE_SYNC" || $compensation_mode == "COMPENSATION_MODE_NON_DEDICATED_NORMAL"} {
                set clk_string_length [string length $clock_to_compensate]
                set clock_to_compensate_index [string index $clock_to_compensate [expr {$clk_string_length - 1}] ]
                if {$counter_index == $clock_to_compensate_index} {
                    set clock_mult $mcnt
                    # Instead of dividing by N, we just divide by 1
                    # since a clock based on the N counter would be created
                    # if N > 1 and this clock would be derived based on that,
                    # so we already have a division happening.
                    set clock_div 1
                } else {
                    set clock_mult [expr $mcnt * $compensated_counter_div]
                    set clock_div $ccnt
                }
            } else {
                ai_post_message debug "Normal C counter"
                set clock_mult $mcnt
                set clock_div $ccnt
            }
        }
    }
    return [list $clock_mult $clock_div]

}
# ----------------------------------------------------------------
#
proc ai_get_pll_atom_parameters {instname} {
#
# Description: Gets the PLL paramaters from the Quartus atom and not 
#              from the IP generated parameters.
#
# ----------------------------------------------------------------

    set pll_atom [ai_get_pll_atom $instname]
    
    set atom_type [get_atom_node_info -key ENUM_ATOM_TYPE -node $pll_atom]
    
    if {$atom_type == "TENNM_PH2_IOPLL"} {
																			 
        dict set pll_params compensation_mode [get_atom_node_info -key COMPENSATION_MODE -node $pll_atom]
        dict set pll_params clock_to_compensate [get_atom_node_info -key COMPENSATION_CLK_SOURCE -node $pll_atom]
        dict set pll_params prot_mode [get_atom_node_info -key PROTOCOL_MODE -node $pll_atom]

        # Get refclk frequency (might have changed since IP generation)
        set refclk_freq_bin [get_atom_node_info -key REF_CLK_0_FREQ -node $pll_atom]
        set refclk_freq_hz [expr "0b$refclk_freq_bin"]
    
        set refclk_period [expr 1000000000.0 / $refclk_freq_hz]
        dict set pll_params refclk_period $refclk_period

        dict set pll_params m_total [get_atom_node_info -key FB_CLK_M_DIV -node $pll_atom]
        if {[dict get $pll_params m_total] == 1} {
            dict set pll_params m_bypass 1
        } else {
            dict set pll_params m_bypass 0    
        }
        dict set pll_params n_total [get_atom_node_info -key REF_CLK_N_DIV -node $pll_atom]
        if {[dict get $pll_params n_total] == 1} {
            dict set pll_params n_bypass 1
        } else {
            dict set pll_params n_bypass 0    
        }


        for { set i 0 } { $i < 7} { incr i } {
            # Get the C counter parameter settings from the atom netlist
            dict set pll_params c${i}_total [get_atom_node_info -key OUT_CLK_${i}_C_DIV -node $pll_atom]
            dict set pll_params duty_cycle${i} [get_atom_node_info -key OUT_CLK_${i}_DUTYCYCLE_PERCENT -node $pll_atom]
        }
    } else {
    	dict set pll_params compensation_mode [get_atom_node_info -key ENUM_IOPLL_FEEDBACK -node $pll_atom]
    	dict set pll_params clock_to_compensate [get_atom_node_info -key INT_IOPLL_CLOCK_TO_COMPENSATE -node $pll_atom]
    
        # Get refclk frequency (might have changed since IP generation)
        set refclk_freq [get_atom_node_info -key TIME_REFERENCE_CLOCK_FREQUENCY -node $pll_atom]
        set refclk_int [string trim $refclk_freq "*MHZmhz"]
        set refclk_period [expr 1000.0 / $refclk_int]
        dict set pll_params refclk_period $refclk_period
    
    	dict set pll_params m_hi_div [get_atom_node_info -key INT_IOPLL_M_CNT_HI_DIV -node $pll_atom]
    	dict set pll_params m_lo_div [get_atom_node_info -key INT_IOPLL_M_CNT_LO_DIV -node $pll_atom]
    	dict set pll_params m_bypass [get_atom_node_info -key BOOL_IOPLL_M_CNT_BYPASS_EN -node $pll_atom]
        if {[dict get $pll_params m_bypass]} {
            set total 1
        } else {
            set total  [expr [dict get $pll_params m_hi_div] + [dict get $pll_params m_lo_div]]
        }
    	dict set pll_params m_total $total
    
    	dict set pll_params n_hi_div [get_atom_node_info -key INT_IOPLL_N_CNT_HI_DIV -node $pll_atom]
    	dict set pll_params n_lo_div [get_atom_node_info -key INT_IOPLL_N_CNT_LO_DIV -node $pll_atom]
    	dict set pll_params n_bypass [get_atom_node_info -key BOOL_IOPLL_N_CNT_BYPASS_EN -node $pll_atom]
        if {[dict get $pll_params n_bypass]} {
            set total 1
        } else {
            set total  [expr [dict get $pll_params n_hi_div] + [dict get $pll_params n_lo_div]]
        }
    	dict set pll_params n_total $total
    
    	for { set i 0 } { $i < 9} { incr i } {
            # Get the C counter parameter settings from the atom netlist
            dict set pll_params c${i}_hi_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_HI_DIV -node $pll_atom]
            dict set pll_params c${i}_lo_div [get_atom_node_info -key INT_IOPLL_C_CNT_${i}_LO_DIV -node $pll_atom]
            dict set pll_params c${i}_bypass [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_BYPASS_EN -node $pll_atom]
            dict set pll_params c${i}_odd_div_duty_en [get_atom_node_info -key BOOL_IOPLL_C_CNT_${i}_EVEN_DUTY_EN -node $pll_atom]
    
            # Calculate the total counter value
            if {[dict get $pll_params c${i}_bypass]} {
                set total 1
            } else {
                set total [expr [dict get $pll_params c${i}_hi_div] + [dict get $pll_params c${i}_lo_div]]
            }
            dict set pll_params c${i}_total $total
    
            # Calculate the duty cycle
            if {[dict get $pll_params c${i}_bypass]} {
                set total_duty 50
            } else {
                if {[dict get $pll_params c${i}_odd_div_duty_en]} {
                    set duty_tweak 1
                } else {
                    set duty_tweak 0
                }
                set total_duty [expr (([dict get $pll_params c${i}_hi_div] - (0.5*$duty_tweak))*100)/$total]
    		    set total_duty [format %.3f $total_duty]
            }
            dict set pll_params duty_cycle${i} $total_duty
        }    
    }

    return $pll_params
}

#__ACDS_USER_COMMENT__Set max delay if in fit flow, otherwise set false path through "through_pin"
# originally in the LVDS SDC. This is called if we are exporting loaden to LVDS
proc set_max_delay_in_fit_or_false_path_in_sta_through_no_warn {through_pin delay} {

    set through_pin_collection [get_pins -compatibility_mode -nowarn $through_pin]
    if {[get_collection_size $through_pin_collection] <= 0} { return }
    
    # if fit_flow == 1
    if {$::TimeQuestInfo(nameofexecutable) == "quartus_fit" } { 
        set_max_delay -through $through_pin_collection $delay
    } else { 
        set_false_path -through $through_pin_collection
    } 
}

# ----------------------------------------------------------------
#
proc is_m_n_cntr {pattern} {
#
# Description: Determines if a pattern matches m/n_cntr
#
# ----------------------------------------------------------------

    if {[string match "*fourteennm_pll~ncntr_reg" $pattern]||[string match "*tennm_pll~ncntr_reg" $pattern]||
        [string match "*fourteennm_pll~mcntr_reg" $pattern]||[string match "*tennm_pll~mcntr_reg" $pattern]||
        [string match "*tennm_ph2_iopll~ncntr_reg" $pattern]||[string match "*tennm_ph2_iopll~mcntr_reg" $pattern]} {
            return 1
    } else {
        return 0
    }
}

# ----------------------------------------------------------------
#
proc create_non_virtual_generated_clock_with_master_or_source \
{master source name multiply_by divide_by phase duty_cycle pin_node_name} {
#
# Description: Creates a non-virtual generated clock using
#              the -source or the -master argument
#
# ----------------------------------------------------------------
    if {$master != ""} {
        create_generated_clock -add \
            -master $master \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle \
            $pin_node_name
    } else {
        create_generated_clock -add \
            -source $source \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle \
            $pin_node_name
    }
}

# ----------------------------------------------------------------
#
proc create_virtual_generated_clock_with_master_or_source \
{master source name multiply_by divide_by phase duty_cycle} {
#
# Description: Creates a virtual generated clock using
#              the -source or the -master argument
#
# ----------------------------------------------------------------
    if {$master != ""} {
        create_generated_clock -add \
            -master $master \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle
    } else {
        create_generated_clock -add \
            -source $source \
            -name $name \
            -multiply_by $multiply_by \
            -divide_by $divide_by \
            -phase $phase \
            -duty_cycle $duty_cycle
    }
}

# ----------------------------------------------------------------
#
proc get_master_clock_given_refclk_src \
{refclk_src} {
#
# Description: Performs string comparisons to determine the master
#              clock that feeds a particular PLL refclk iterm
#
# ----------------------------------------------------------------
    set refclk_fanin_edge [get_node_info -clock_edges $refclk_src]
    set fanin_pin [get_node_info -name [get_edge_info -src $refclk_fanin_edge]]
    set clocks [get_clocks -nowarn -of_objects $fanin_pin]
    foreach_in_collection clk $clocks {
        set clk_name [get_clock_info -name $clk]
        set pll_path [regsub {[^|]+$} $clk_name ""]
        if {[string first $pll_path $refclk_src] == 0} {
            return $clk
        }
    }
}
 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 12 pcie_ed_pio0 22 intel_pcie_pio_gts_234 5 synth 35 altera_pcie_s10_gen3x16_adapter.sdc 12085 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2020 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# (C) 2001-2019 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


proc apply_cdc {from_keep to_keep} {
if {[llength [query_collection -report -all $from_keep]] > 0 && [llength [query_collection -report -all $to_keep]] > 0} {
set_max_skew -from $from_keep -to $to_keep -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_keep -to $to_keep -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.85
}
set_max_delay -from $from_keep -to $to_keep 50
set_min_delay -from $from_keep -to $to_keep -50}
}

proc apply_cdc_to_bit {to_keep} {
  if {[llength [query_collection -report -all $to_keep]] > 0} {
    set_max_delay -to $to_keep 50
    set_min_delay -to $to_keep -50
    set fanins [get_fanins -no_logic $to_keep]
#    foreach_in_collection fanins $fanins {
      if {[llength [query_collection -report -all $fanins]] > 0} {
        if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
            set_net_delay -from $fanins -to $to_keep -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
        }
      }
#    }
  }
}

proc apply_cdc_from_bit {from_keep} {
  set_max_delay -from $from_keep 50
  set_min_delay -from $from_keep -50
  set fanouts [get_fanouts -no_logic $from_keep]
#  foreach_in_collection fanouts $fanouts {
    if {[llength [query_collection -report -all $fanouts]] > 0} {
      if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
          set_net_delay -from $from_keep -to $fanouts -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
      }
#    }
  }  
}

##########################################################################################################################################
# Set max skew between the gray code pointers of TX_ST fifos.
set from_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx0|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx0|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

set from_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx1|din_gry*]
set to_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_tx_st_if|tx_fifo_lo|*gx1|u_din_gry_sync|sync_regs_s1*]
apply_cdc $from_keep $to_keep

##########################################################################################################################################
#
## Set max skew between the gray code pointers of RX_ST fifos.
#set from_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo|*gx0|din_gry*]
#set to_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo|*gx0|u_din_gry_sync|sync_regs_s1*]
#apply_cdc $from_keep $to_keep
#
#set from_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo|*gx1|din_gry*]
#set to_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo|*gx1|u_din_gry_sync|sync_regs_s1*]
#apply_cdc $from_keep $to_keep
#
set to_keep [get_keepers -nowarn *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_st_ready]
apply_cdc_to_bit $to_keep
#
##########################################################################################################################################
set to_keep [get_keepers -nowarn *pll_rstn_d1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *pll_rstn_d2*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *pio_rstn_d1*]
apply_cdc_to_bit $to_keep

set to_keep [get_keepers -nowarn *pio_rstn_d2*]
apply_cdc_to_bit $to_keep
##########################################################################################################################################

##########################################################################################################################################

set to_keep [get_keepers -nowarn *|u_tx_st_if|sync_comb_rst_d1*]
if {[get_collection_size $to_keep] > 0} {
   set_false_path -to $to_keep
}

##########################################################################################################################################
#set_false_path -from [get_keepers *soft_logics|rst_ctrl|*rst_tree|reset_status_tree*] -to [get_keepers *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo_lo|auto_generated|fifo_altera_syncram|altera_syncram_impl5|ram_block*]
##########################################################################################################################################
# Apply cdc constraints to reset
set to_keep [get_keepers -nowarn *reset_status_250sync|din_s1*]
apply_cdc_to_bit $to_keep

set from_keep [get_keepers -nowarn *altera_avst512_iopll|altera_ep_g3x16_avst512_io_pll_s10|*]
set to_keep [get_keepers -nowarn *reset_status_250sync|dreg*]
if {[get_collection_size $from_keep] > 0 & [get_collection_size $to_keep] > 0} {
   set_false_path -from $from_keep -to $to_keep
}

##########################################################################################################################################
#############Fix Warning##################################################################################################################
set to_keep [get_keepers -nowarn *auto_generated|*wraclr|dffe*]
if {[get_collection_size $to_keep] > 0} {
set_false_path -to *auto_generated|*wraclr|dffe*
#set_false_path -to *auto_generated|*rdaclr|dffe*
}

##########################################################################################################################################

##########################################################################################################################################
#CDC for cdts_fifo
proc apply_sdc_dcfifo {hier_path} {
# gray_rdptr
apply_sdc_dcfifo_rdptr $hier_path
# gray_wrptr
apply_sdc_dcfifo_wrptr $hier_path
}
#
# common constraint setting proc
#
proc apply_sdc_dcfifo_for_ptrs {from_node_list to_node_list} {
# control skew for bits
set_max_skew -from $from_node_list -to $to_node_list -get_skew_value_from_clock_period src_clock_period -skew_value_multiplier 0.8
# path delay (exception for net delay)
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
#relax setup and hold calculation
set_max_delay -from $from_node_list -to $to_node_list 100
set_min_delay -from $from_node_list -to $to_node_list -100
}
#
# mstable propgation delay
#
proc apply_sdc_dcfifo_mstable_delay {from_node_list to_node_list} {
# mstable delay
if { ![string equal "quartus_syn" $::TimeQuestInfo(nameofexecutable)] } {
set_net_delay -from $from_node_list -to $to_node_list -max -get_value_from_clock_period dst_clock_period -value_multiplier 0.8
}
}
#
# rdptr constraints
#
proc apply_sdc_dcfifo_rdptr {hier_path} {
# get from and to list
set from_node_list [get_keepers -nowarn $hier_path|auto_generated|*rdptr_g*]
set to_node_list [get_keepers -nowarn $hier_path|auto_generated|ws_dgrp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_list]] > 0 && [llength [query_collection -report -all $to_node_list]] > 0} {
  apply_sdc_dcfifo_for_ptrs $from_node_list $to_node_list
}
# mstable
set from_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|ws_dgrp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|ws_dgrp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_mstable_list]] > 0 && [llength [query_collection -report -all $to_node_mstable_list]] > 0} {
  apply_sdc_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}
}
#
# wrptr constraints
#
proc apply_sdc_dcfifo_wrptr {hier_path} {
# control skew for bits
set from_node_list [get_keepers -nowarn $hier_path|auto_generated|delayed_wrptr_g*]
set to_node_list [get_keepers -nowarn $hier_path|auto_generated|rs_dgwp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_list]] > 0 && [llength [query_collection -report -all $to_node_list]] > 0} {
  apply_sdc_dcfifo_for_ptrs $from_node_list $to_node_list
}
# mstable
set from_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|rs_dgwp|dffpipe*|dffe*]
set to_node_mstable_list [get_keepers -nowarn $hier_path|auto_generated|rs_dgwp|dffpipe*|dffe*]
if {[llength [query_collection -report -all $from_node_mstable_list]] > 0 && [llength [query_collection -report -all $to_node_mstable_list]] > 0} {
  apply_sdc_dcfifo_mstable_delay $from_node_mstable_list $to_node_mstable_list
}
}

set fifo_loc *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo_lo*
apply_sdc_dcfifo $fifo_loc

set fifo_loc *altera_pcie_256s_512s_adapter_inst|u_rx_st_if|rx_fifo_hi*
apply_sdc_dcfifo $fifo_loc

##########################################################################################################################################
 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 12 pcie_ed_pio0 16 intelclkctrl_200 5 synth 41 pcie_ed_pio0_intelclkctrl_200_f3nubzq.sdc 30592 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#__ACDS_USER_COMMENT__####################################################################
#__ACDS_USER_COMMENT__
#__ACDS_USER_COMMENT__ THIS IS AN AUTO-GENERATED FILE!
#__ACDS_USER_COMMENT__ -------------------------------
#__ACDS_USER_COMMENT__ Note: all changes to this file will be overwritten when the core is regenerated
#__ACDS_USER_COMMENT__
#__ACDS_USER_COMMENT__ FILE DESCRIPTION
#__ACDS_USER_COMMENT__ ----------------
#__ACDS_USER_COMMENT__ This file contains the timing constraints for the clock divider
#__ACDS_USER_COMMENT__

set script_dir [file dirname [info script]]

#__ACDS_USER_COMMENT__ Set global parameters
source "$script_dir/pcie_ed_pio0_intelclkctrl_200_f3nubzq_parameters.tcl"

#__ACDS_USER_COMMENT__ Load the design package in order to retrieve a list of clock divider instances
load_package design

#__ACDS_USER_COMMENT__ Required for proper clock constraints
derive_clock_uncertainty

#__ACDS_USER_COMMENT__ Returns a map of clock targets to clock names for the design
proc get_target_to_clock_map { map } {

        upvar 1 $map target_to_clock_map

        #__ACDS_USER_COMMENT__ Obtain the clocks that have been created in the design
        set current_clocks [get_clocks]

        #__ACDS_USER_COMMENT__ Map the clocks in the design to their targets
        set target_to_clock_map [dict create]
        
        #__ACDS_USER_COMMENT__ Iterate over clocks in the design
        foreach_in_collection clk_id $current_clocks {

                #__ACDS_USER_COMMENT__ Query the targets for this clock
                set target_col [get_clock_info -targets $clk_id]

                #__ACDS_USER_COMMENT__ Virtual clocks have no target
                if { 0 == [get_collection_size $target_col] } {
                        continue
                }

                #__ACDS_USER_COMMENT__ Retrieve the clock name
                set clock_name [get_clock_info -name $clk_id]
                       
                #__ACDS_USER_COMMENT__ Iterate over the targets
                foreach_in_collection target_id $target_col {
                
                        #__ACDS_USER_COMMENT__ Retrieve target name and clock name
                        set target_name [get_node_info -name $target_id]
 
                        #__ACDS_USER_COMMENT__ Store mapping from target name to clock name
                        dict lappend target_to_clock_map $target_name $clock_name

                        #__ACDS_USER_COMMENT__ If a clock is created on a net, add a entry for 
                        #__ACDS_USER_COMMENT__ the pin as well.  This will ensure it is found 
                        #__ACDS_USER_COMMENT__ during the fanin traversals later
                        set target_type [get_node_info -type $target_id]
                        if { $target_type eq "net" } {
                                set pin_id [get_net_info -pin $target_id]
                                set pin_name [get_pin_info -name $pin_id]
                                dict lappend target_to_clock_map $pin_name $clock_name
                        }
                }
        }
}

#__ACDS_USER_COMMENT__ Make a graph to do topological sort of the clock divider instantiations
#__ACDS_USER_COMMENT__ Note that only instantiations of the current parameterization are processed by this file.
proc get_adjacency_list { instances } {

        set adjacency_list [dict create]

        #__ACDS_USER_COMMENT__ Iterate through all instances
        for {set curr_idx 0} {$curr_idx < [llength $instances]} {incr curr_idx} {
                set curr_inst [lindex $instances $curr_idx]
                
                #__ACDS_USER_COMMENT__ Iterate through all other instances to find 
                #__ACDS_USER_COMMENT__ the ones upstream of the current instance
                set upstream_instances [list]
                foreach other_inst $instances {
        
                        #__ACDS_USER_COMMENT__ Assume an instance is never a fanin of itself
                        if {$curr_inst eq $other_inst} {
                                continue
                        }

                        #__ACDS_USER_COMMENT__ See if other_inst is a fanin of curr_inst
                        set other_inst_nets [get_nets -nowarn "${other_inst}|*"]
                        set curr_inst_regs [get_registers -nowarn "${curr_inst}|clkdiv_inst*"]
                        if { 0 == [get_collection_size $other_inst_nets] || 0 == [get_collection_size $curr_inst_regs] } {
                                continue
                        }                        
                        
                        set fanin_col [get_fanins -through $other_inst_nets $curr_inst_regs]
                        if { [get_collection_size $fanin_col] > 0} {
                                lappend upstream_instances $other_inst
                                
                                #__ACDS_USER_COMMENT__ Add the upstream instances to the adjacency list
                                #__ACDS_USER_COMMENT__ Store the adjacency list in terms of indices
                                for {set fanin_idx 0} {$fanin_idx < [llength $instances]} {incr fanin_idx} {
                                        if { $other_inst eq [lindex $instances $fanin_idx] } {
                                                dict lappend adjacency_list $fanin_idx $curr_idx
                                                break
                                        }
                                }
                        }
                }
        }

        return $adjacency_list
}

#__ACDS_USER_COMMENT__ Depth-first search for topological sort
proc dfs_visit {edges n color_list result_list} {
        upvar 1 $color_list color
        upvar 1 $result_list result
        
        if {[lindex $color $n] == "black"} {
                return
        } elseif {[lindex $color $n] == "grey" } {
                error "Topological sort failed, cycle detected!"
        }
    
        set color [lreplace $color $n $n "grey"]
    
        if [dict exists $edges $n] {
                foreach m [dict get $edges $n] {
                        dfs_visit $edges $m color result
                }
        }
    
        set color [lreplace $color $n $n "black"]
        set result [linsert $result 0 $n]
}

#__ACDS_USER_COMMENT__ Depth-first search for topological sort
proc dfs { edges num_nodes } {

        set result [list]

        set color [list]
        for {set i 0} {$i < $num_nodes} {incr i} {
                lappend color "white"
        }

        set n [lsearch $color "white"]
        while { $n != -1 } {
                dfs_visit $edges $n color result
                set n [lsearch $color "white"]
        }
        return $result
}

#__ACDS_USER_COMMENT__ Sort the instances of the current parameterization
proc topological_sort { instances } {

        #__ACDS_USER_COMMENT__ Represent the connectivity graph between the instances 
        #__ACDS_USER_COMMENT__ as an adjaency list of indices
        set edges [get_adjacency_list $instances]

        #__ACDS_USER_COMMENT__ Depth-first search topological sort
        set order [dfs $edges [llength $instances] ]
    
        #__ACDS_USER_COMMENT__ Convert from indices back to instance names
        set result [list]
        foreach index $order {
                lappend result [lindex $instances $index ]
        }
        
        #__ACDS_USER_COMMENT__ Return the sorted instance names
        return $result
}

#__ACDS_USER_COMMENT__ Issue warning for instances that will be skipped
proc warn_skipped_instances { skipped_instances } {

        set target_to_clock_map [dict create]
        get_target_to_clock_map target_to_clock_map
        
        #__ACDS_USER_COMMENT__ Iterate over all clock divider instances passed in
        foreach clock_div_inst $skipped_instances {

                post_message -type warning "The intelclkctrl SDC script will not constrain clock divider\
                output clocks for ${clock_div_inst} because a cycle was detected. "
                
                #__ACDS_USER_COMMENT__ Iterate over all clock divider outputs
                for {set outclk 0} {$outclk < $::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_out_clocks} {incr outclk} {
                
                        set divisor [expr {2 ** $outclk}]
                        set msg "You must constrain ${clock_div_inst}|clkdiv_inst|clockdiv${divisor}."
                        set submsgs [list]
                
                        #__ACDS_USER_COMMENT__ Trace fanins to suggest possible clock sources
                        set clock_fanins [dict create]
                        set other_fanins [dict create]
                        set clkdiv_inclk "${clock_div_inst}|clkdiv_inst|inclk"
                        trace_fanins $clkdiv_inclk $target_to_clock_map clock_fanins other_fanins
        
                        if { [ dict size $clock_fanins ] > 0 } {
                                lappend submsgs "Possible clock sources:"
                                dict for { clock_fanin clock_name } $clock_fanins {
                                        lappend submsgs "${clock_fanin} (name ${clock_name})"
                                }
                        } else {
                                lappend submsgs "Possible sources that are not marked as clocks:"
                                dict for { other_fanin other_fanin_type } $other_fanins {
                                        lappend submsgs "${other_fanin} (type ${other_fanin_type})"
                                }
                        }
                        post_message -type warning $msg -submsg $submsgs
                }
        }
}

#__ACDS_USER_COMMENT__ Depth-first search to identify islands (connected components) in the graph
proc dfs_island { edges n curr_color visited_list} {
        upvar 1 $visited_list visited

        if {[lindex $visited $n] ne "unvisited"} {
                return
        }
    
        set visited [lreplace $visited $n $n $curr_color]
    
        if [dict exists $edges $n] {
                foreach m [dict get $edges $n] {
                        dfs_island $edges $m $curr_color visited
                }
        }
}


#__ACDS_USER_COMMENT__ Identify islands (connected components) in the graph
proc find_islands { instances visited_list } {
        upvar 1 $visited_list visited

        #__ACDS_USER_COMMENT__ Represent the connectivity graph between the instances 
        #__ACDS_USER_COMMENT__ as an adjaency list of indices
        set edges [get_adjacency_list $instances]
    
        #__ACDS_USER_COMMENT__ Create an undirected graph by adding all reverse edges
        set undirected_edges [dict create]
        dict for { src dsts } $edges {
                foreach dst $dsts {
                        if { ![dict exists $undirected_edges $src] } {
                                dict set undirected_edges $src [list]
                        }
                        if { $dst ni [dict get $undirected_edges $src] } {
                                dict lappend undirected_edges $src $dst
                        }
                        if { ![dict exists $undirected_edges $dst] } {
                                dict set undirected_edges $dst [list]
                        }
                        if { $src ni [dict get $undirected_edges $dst] } {
                                dict lappend undirected_edges $dst $src
                        }
                }
        }

        #__ACDS_USER_COMMENT__ Initialize all nodes as unvisited
        set num_nodes [llength $instances]
        for {set i 0} {$i < $num_nodes} {incr i} {
                lappend visited "unvisited"
        }    

        #__ACDS_USER_COMMENT__ Depth-first search to assign a color to nodes that are connected
        set curr_color 0
        set n [lsearch $visited "unvisited"]
        while { $n != -1 } {
                dfs_island $undirected_edges $n $curr_color visited
                set n [lsearch $visited "unvisited"]
                incr curr_color
        }    

        #__ACDS_USER_COMMENT__ Return number of colors (number of islands)
        return $curr_color
}


#__ACDS_USER_COMMENT__ Returns a list of clock divider instances
proc get_clock_divider_instances {} {

        set sorted_instances [list]

        #__ACDS_USER_COMMENT__ Retrieve a list of clock divider instances
        set core $::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_core
        set instances [design::get_instances -entity $core]
        
        #__ACDS_USER_COMMENT__ No clock divider instances were detected
        if {[ llength $instances ] == 0} {
                post_message -type warning "The intelclkctrl SDC script was unable to detect\
                any instances of core < ${core} >"
        }
        
        #__ACDS_USER_COMMENT__ Separate the instances into ialands (connected components)
        #__ACDS_USER_COMMENT__ The island_idex list is parallel to the instances list
        set island_idx [list]
        set num_islands [find_islands $instances island_idx]
        
        #__ACDS_USER_COMMENT__ Iterate over all islands
        for { set inum 0 } { $inum < $num_islands } { incr inum } {

                #__ACDS_USER_COMMENT__ Identify the instances within the current island
                set connected_instances [list]
                for {set i 0} {$i < [llength $instances]} {incr i} {
                        if {[lindex $island_idx $i] == $inum } {
                                lappend connected_instances [lindex $instances $i]
                        }
                }
                
                #__ACDS_USER_COMMENT__ Perform topological sort on in instances within the current island
                if  {[ catch  {set connected_instances [topological_sort $connected_instances]} errmsg]} {
                        #__ACDS_USER_COMMENT__ If sorting failed, skip these instances
                        post_message -type warning $errmsg
                        post_message -type warning "The intelclkctrl SDC script was unable to determine\
                        a topological ordering for the instances of < ${core} >."
                        warn_skipped_instances $connected_instances
                } else {
                        #__ACDS_USER_COMMENT__ Store the sorted instances
                        foreach inst $connected_instances {
                                lappend sorted_instances $inst
                        }
                }
        }

        #__ACDS_USER_COMMENT__ Append "|clkdiv_inst|" to each instance name
        for {set inst_i 0} {$inst_i < [llength $sorted_instances]} {incr inst_i} {
                lset sorted_instances $inst_i [lindex $sorted_instances $inst_i]|clkdiv_inst|
        }
        return $sorted_instances
}



#__ACDS_USER_COMMENT__ Check if any clocks have already been generated on the clock divider outputs
proc any_output_clocks_already_exist { inst target_to_clock_map } {

        set retval 0
        set previous_clocks 0
        set submsgs [list]
        set divisors [ list 1 2 4 ]

        #__ACDS_USER_COMMENT__ Go through the output pins of the clock divider
        for {set outclk 0} {$outclk < $::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_out_clocks} {incr outclk} {

                #__ACDS_USER_COMMENT__ Derive the name of the clock divider output
                set divisor [lindex $divisors $outclk]
                set target "${inst}clock_div${divisor}"

                #__ACDS_USER_COMMENT__ Check whether a clock has already been created
                if { [dict exists $target_to_clock_map $target] } {
                        lappend submsgs "Found a clock on ${target}."
                        incr previous_clocks
                } else {
                        lappend submsgs "Did not find a clock on ${target}."
                }
        }
        
        #__ACDS_USER_COMMENT__ If clocks have been previously defined, issue a warning
        if { $previous_clocks > 0} {
                set retval 1
                set clock_div_inst [string trim $inst "|"]
                set msg "The intelclkctrl SDC script will not constrain clock divider\
                output clocks for ${clock_div_inst} because one or more output clocks were previously defined. "
                post_message -type warning $msg -submsg $submsgs
        }
        
        return $retval
}



#__ACDS_USER_COMMENT__ Get the clock fanins and non-clock fanins of this clock divider
proc trace_fanins { clkdiv_inclk target_to_clock_map clock_dict other_dict } {

        upvar 1 $clock_dict clock_fanins
        upvar 1 $other_dict other_fanins

        #__ACDS_USER_COMMENT__ Trace the fanins of the clock divider
        set fanins [get_fanins -clock -stop_at_clock $clkdiv_inclk]
        foreach_in_collection fanin_id $fanins {
        
                #__ACDS_USER_COMMENT__ Retrieve the fanin name from the fanin node
                set fanin [get_object_info -name $fanin_id]

                #__ACDS_USER_COMMENT__ If the fanin is found in the map, it is a clock
                if { [dict exists $target_to_clock_map $fanin] } {
                
                        #__ACDS_USER_COMMENT__ Store clock fanin
                        set user_clock [dict get $target_to_clock_map $fanin]
                        dict lappend clock_fanins $fanin {*}$user_clock

                #__ACDS_USER_COMMENT__ Otherwise it is a non-clock fanin
                } else {
                
                        #__ACDS_USER_COMMENT__ Store non-clock fanin
                        set fanin_type [get_object_info -type $fanin_id]
                        dict lappend other_fanins $fanin $fanin_type
                }
        }
}        



#__ACDS_USER_COMMENT__ If there is a single non-clock fanin and it is a port, create a clock on it
#__ACDS_USER_COMMENT__ Returns 1 if a clock was created, 0 otherwise
proc add_clock_on_single_fanin_that_is_a_port { clock_dict other_dict target_to_clock_map } {

        upvar 1 $clock_dict clock_fanins
        upvar 1 $other_dict other_fanins

        set retval 0
        
        #__ACDS_USER_COMMENT__ If there is a single fanin that is not a clock
        if { (0 == [llength [dict keys $clock_fanins]]) && (1 == [llength [dict keys $other_fanins]]) } {
        
                #__ACDS_USER_COMMENT__ Get the fanin and its type
                set fanin_id [lindex [dict get $other_fanins] 0]
                set fanin_type [lindex [dict get $other_fanins] 1]
                        
                #__ACDS_USER_COMMENT__ If it is a port, create a clock
                if { $fanin_type eq "port" } {
                        
                        #__ACDS_USER_COMMENT__ The created clock will have the same name as the port
                        set clock_name [get_node_info -name $fanin_id]
                        
                        #__ACDS_USER_COMMENT__ The created clock will have a default period of 1ns
                        set period 1.000

                        #__ACDS_USER_COMMENT__ Create the clock on the port
                        post_message -type info "The intelclkctrl SDC script created clock\
                        ${clock_name} with default period ${period} ns."
                        create_clock -period $period $fanin_id
                                
                        #__ACDS_USER_COMMENT__ Add a new entry to clock_fanins
                        dict lappend clock_fanins $clock_name $clock_name
                        
                        #__ACDS_USER_COMMENT__ Add a new entry to target_to_clock_map
                        dict lappend target_to_clock_map $clock_name $clock_name

                        #__ACDS_USER_COMMENT__ Remove the entry from other_fanins
                        dict unset other_fanins $clock_name

                        set retval 1
                }
        }
        return $retval
}



#__ACDS_USER_COMMENT__ Issue warnings because there are no clock sources for this clock divider
#__ACDS_USER_COMMENT__ This should only be called if there are zero clock fanins
proc warn_no_clock_sources { clkdiv_inclk clock_fanins other_fanins } {

        #__ACDS_USER_COMMENT__ No fanins were detected
        if { 0 == [ dict size $other_fanins ] } {

                post_message -type warning "The intelclkctrl SDC script cannot constrain\
                clock divider output clocks because no fanins were found for ${clkdiv_inclk}."
                
        #__ACDS_USER_COMMENT__ At least one fanin was detected, but none of the fanins are clocks
        } elseif { [ dict size $other_fanins ] > 0 } {
        
                #__ACDS_USER_COMMENT__ Suggest the non-clock inputs detected as possible clocks
                set submsgs [list]
                dict for { other_fanin other_fanin_type } $other_fanins {
                        lappend submsgs "${other_fanin} (type ${other_fanin_type})"
                }

                set advice1 "If you have a SDC script that creates clocks on the above fanin(s),\
                please ensure that SDC script is listed before the clock control IP in the QSF file."
                set advice2 "If the SDC script from another IP creates clocks on the above fanin(s),\
                please ensure that IP is listed before the clock control IP in the QSF file."
                lappend submsgs $advice1
                lappend submsgs $advice2

                #__ACDS_USER_COMMENT__ Post warning message
                set msg "The intelclkctrl SDC script cannot constrain clock divider output\
                clocks because no clock fanins were found for $clkdiv_inclk.  You may need\
                to call create_clock on one or more of the following the fanin(s):"
                post_message -type warning $msg -submsg $submsgs
        }
}


#__ACDS_USER_COMMENT__ Issue warnings if there are fewer clock fanins than mux inputs
proc warn_missing_clock_sources { clkdiv_inclk num_mux_inputs clock_dict other_dict } {

        upvar 1 $clock_dict clock_fanins
        upvar 1 $other_dict other_fanins
        
        #__ACDS_USER_COMMENT__ Find the names of the clock fanins
        set clock_submsgs [list]
        dict for { clock_fanin clock_name } $clock_fanins {
                lappend clock_submsgs "${clock_fanin} (name ${clock_name})"
        }

        #__ACDS_USER_COMMENT__ Issue warnings if there are fewer clock fanins than mux inputs
        set num_clock_fanins [ dict size $clock_fanins ]
        if { $num_clock_fanins < $num_mux_inputs } {

                set msg "The intelclkctrl SDC script expected ${num_mux_inputs} clock inputs but\
                found only ${num_clock_fanins} clock fanin(s) for ${clkdiv_inclk}.  The following\
                clock fanins were found: "
                post_message -type warning $msg -submsg $clock_submsgs

                #__ACDS_USER_COMMENT__ Suggest the non-clock inputs detected as possible clocks
                if { [ dict size $other_fanins ] > 0 } {
                        set other_submsgs [list]
                        dict for { other_fanin other_fanin_type } $other_fanins {
                                lappend other_submsgs "${other_fanin} (type ${other_fanin_type})"
                        }
                        
                        #__ACDS_USER_COMMENT__ Post warning message
                        set msg "You may need create_clock on one or more of the following fanin(s): "
                        post_message -type warning $msg -submsg $other_submsgs
                }
        }
}


#__ACDS_USER_COMMENT__ Constrain clock divider outputs using generated clocks
proc add_generated_clocks { source divider_output divisor master_clock add_master } {

        #__ACDS_USER_COMMENT__ Return nothing if this clock divider output is not connected
        if { 0 == [get_collection_size [get_pins -nowarn $divider_output]] } {
                return ""
        }

        #__ACDS_USER_COMMENT__ Derive target
        set target [get_pins $divider_output]

        #__ACDS_USER_COMMENT__ Generate the constraint without master clock specified
        if { 0 == $add_master } {

                set name $divider_output
                post_message -type info "Constrained clock divider output clock\
                ${divider_output} to ${source}."
                create_generated_clock -add \
                        -name $name \
                        -source $source \
                        -divide_by $divisor \
                        $target

        #__ACDS_USER_COMMENT__ Generate the constraint with master clock specified
        } else {

                set name "${divider_output}_${master_clock}"
                post_message -type info "Constrained clock divider output clock\
                ${divider_output} to ${source} (master name ${master_clock})."
                create_generated_clock -add \
                        -name $name  \
                        -source $source \
                        -master_clock $master_clock \
                        -divide_by $divisor \
                        $target
        }
        return $name
}


#__ACDS_USER_COMMENT__####################################################################
#__ACDS_USER_COMMENT__
#__ACDS_USER_COMMENT__ Main flow to constraint clock divider outputs
#__ACDS_USER_COMMENT__
#__ACDS_USER_COMMENT__####################################################################


#__ACDS_USER_COMMENT__ Go through all clock divider instances
foreach inst [get_clock_divider_instances] {

        #__ACDS_USER_COMMENT__ Obtain a map of clock targets to clock names for the design
        set target_to_clock_map [dict create]
        get_target_to_clock_map target_to_clock_map

        #__ACDS_USER_COMMENT__ Skip if this clock divider's outputs already have constraints
        if { [ any_output_clocks_already_exist $inst $target_to_clock_map ] } {
                continue
        }

        #__ACDS_USER_COMMENT__ Get the clock and non-clock fanins of this clock divider
        set clock_fanins [dict create]
        set other_fanins [dict create]
        set clkdiv_inclk "${inst}inclk"
        trace_fanins $clkdiv_inclk $target_to_clock_map clock_fanins other_fanins
        
        #__ACDS_USER_COMMENT__ There may be no clock fanins found
        if { 0 == [ dict size $clock_fanins ] } {

               #__ACDS_USER_COMMENT__ Create a clock if appropriate, updating relevant data structures
               if { [add_clock_on_single_fanin_that_is_a_port clock_fanins other_fanins $target_to_clock_map] } {

                       #__ACDS_USER_COMMENT__ One entry has been moved from other_fanins to clock_fanins
                       
               #__ACDS_USER_COMMENT__ Otherwise, issue a warning as no constraints will be generated                       
               } else {
                       warn_no_clock_sources $clkdiv_inclk $clock_fanins $other_fanins
                       continue;
               }
        }
        
        #__ACDS_USER_COMMENT__ Issue warning if there are fewer clock fanins than expected
        set num_clock_fanins [ dict size $clock_fanins ]
        if { $num_clock_fanins < $::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_in_clocks } {
                warn_missing_clock_sources $clkdiv_inclk $::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_in_clocks clock_fanins other_fanins
        }        
        
        #__ACDS_USER_COMMENT__ Iterate over the clock fanins to this clock divider
        set clock_groups [list]
        dict for { clock_fanin clock_name_list } $clock_fanins {
        
                #__ACDS_USER_COMMENT__ If multiple clock inputs, or if multiple clock names on an input,
                #__ACDS_USER_COMMENT__ a master clock will be specified
                set add_master 0        
                if { ( $num_clock_fanins > 1 ) || ( [ llength $clock_name_list ] > 1 ) } {
                        set add_master 1
                }                                

                #__ACDS_USER_COMMENT__ Keep a list of the names of the newly generated clocks
                set new_clocks [list]
                foreach master_clock_name $clock_name_list {

                        #__ACDS_USER_COMMENT__ Constrain each of the clock divider output clocks
                        for {set outclk 0} {$outclk < $::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_out_clocks} {incr outclk} {

                                #__ACDS_USER_COMMENT__ Compute frequency ratio relative to the input clock
                                set divisor [expr {2 ** $outclk}]

                                #__ACDS_USER_COMMENT__ Derive output clock port
                                set target "${inst}clock_div${divisor}"
                                
                                #__ACDS_USER_COMMENT__ Write out statement to constraint output clock
                                set new_clock [add_generated_clocks $clock_fanin $target $divisor $master_clock_name $add_master]
                                if { $new_clock != "" } {
                                        lappend new_clocks $new_clock
                                }
                        }
                }
                lappend clock_groups "-group"
                lappend clock_groups $new_clocks
        }

        #__ACDS_USER_COMMENT__ Specify exclusive clock groups for newly created clocks
        #__ACDS_USER_COMMENT__ This is necessary if there is a clock mux feeding the clock divider
        if { $num_clock_fanins > 1 } {
                post_message -type info "set_clock_groups -exclusive ${clock_groups}"
                set_clock_groups -exclusive {*}$clock_groups
        }
}

 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 12 pcie_ed_pio0 16 intelclkctrl_200 5 synth 52 pcie_ed_pio0_intelclkctrl_200_f3nubzq_parameters.tcl 540 # Clock Divider Parameters

# The clock divider parameters are statically defined in this file at generation time!
# To ensure timing constraints and timing reports are correct, when you make any changes
# to the clock divider component using Qsys, apply those changes to the clock divider
# parameters in this file

set ::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_core pcie_ed_pio0_intelclkctrl_200_f3nubzq

set ::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_out_clocks 2

set ::GLOBAL_pcie_ed_pio0_intelclkctrl_200_f3nubzq_in_clocks 1
 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 15 pcie_ed_resetIP 32 altera_s10_user_rst_clkgate_1947 5 synth 34 altera_s10_user_rst_clkgate_fm.sdc 1468 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


#Create base clock with 100 MHz targetted for internal clocks if paths listed below found in the design

#Agilex
#auto_fab_0|alt_sld_fab_0|alt_sld_fab_0|agilexconfigreset|user_reset|sdm_gpo_out_user_reset~internal_ctrl_clock.reg


set intrl_ctrl_reg_count 0

set intrl_ctrl_reg_collection [get_registers -nowarn "auto_fab*\|*\|*sdm_gpo_out_user_reset~internal_ctrl_clock.reg"]

set intrl_ctrl_reg_count [ get_collection_size $intrl_ctrl_reg_collection ]

if {$intrl_ctrl_reg_count > 0} {

	create_clock -name {internal_clk} -period 10.000 -waveform {0.000 5.000} { auto_fab*|*|*sdm_gpo_out_user_reset~internal_ctrl_clock }

	set_clock_groups -asynchronous -group [get_clocks {internal_clk}]
}



 11 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 2 ip 7 pcie_ed 15 pcie_ed_srcssIP 19 intel_srcss_gts_200 5 synth 47 pcie_ed_srcssIP_intel_srcss_gts_200_bg3co7q.sdc 3365 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.



##intel_srcss_gts IP SDC##


set module_name pcie_ed_srcssIP_intel_srcss_gts_200_bg3co7q



## set global variables
global ::ip_sdc_debug

set ip_sdc_debug 1

## get current IP instance 
set ip_inst_name [get_current_instance]
post_message -type info "IP SDC: $ip_inst_name"



#**************************************************************
# Create Clock
#**************************************************************


#**************************************************************
# Create Generated Clock
#**************************************************************




#Create Clock for the Shoreline reset sequencer 
#create_generated_clock -divide_by 2 -source [get_nodes {*|intosc|oscillator_dut~oscillator_clock}] -name "${ip_inst_name}_src_divided_osc_clk" [get_registers "${ip_inst_name}|inst|divided_osc_clk"]

set src_rs   [get_registers -nowarn ${ip_inst_name}|inst|*_src_rs*[*]]
 
    if {[get_collection_size ${src_rs}] > 0} {
        create_generated_clock -divide_by 2 -source [get_nodes {*|intosc|oscillator_dut~oscillator_clock}] -name "${ip_inst_name}_src_divided_osc_clk" [get_registers "${ip_inst_name}|inst|divided_osc_clk"] 
    }	

			
			
#**************************************************************
# Set Clock Latency
#**************************************************************



#**************************************************************
# Set Clock Uncertainty
#**************************************************************



#**************************************************************
# Set Input Delay
#**************************************************************


#**************************************************************
# Set Output Delay
#**************************************************************

#**************************************************************
# Set Clock Groups
#**************************************************************



#**************************************************************
# Set False Path
#**************************************************************
#**************************************************************



#**************************************************************
# Set Maximum Delay
#**************************************************************



#**************************************************************
# Set Minimum Delay
#**************************************************************



#**************************************************************
# Set Input Transition
#**************************************************************



 9 0 2 C: 8 projects 10 axe5_eagle 4 pcie 7 pcie_ed 7 pcie_ed 28 altera_reset_controller_1922 5 synth 27 altera_reset_controller.sdc 2326 # (C) 2001-2024 Intel Corporation. All rights reserved.
# Your use of Intel Corporation's design tools, logic functions and other 
# software and tools, and its AMPP partner logic functions, and any output 
# files from any of the foregoing (including device programming or simulation 
# files), and any associated documentation or information are expressly subject 
# to the terms and conditions of the Intel Program License Subscription 
# Agreement, Intel FPGA IP License Agreement, or other applicable 
# license agreement, including, without limitation, that your use is for the 
# sole purpose of programming logic devices manufactured by Intel and sold by 
# Intel or its authorized distributors.  Please refer to the applicable 
# agreement for further details.


# +---------------------------------------------------
# | Cut the async clear paths
# +---------------------------------------------------
set aclr_counter 0
set clrn_counter 0

if {[get_current_instance] == ""} {set hpath ""} else {set hpath "[get_current_instance]|*"} 
post_message -type info "Following instance found in the design -  $hpath"

set aclr_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
set clrn_collection [get_pins -compatibility_mode -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
set num_sync_stage [get_registers -nocase -nowarn ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[*]]
set num_sync_count [get_collection_size $num_sync_stage]   
set aclr_counter [get_collection_size $aclr_collection]
set clrn_counter [get_collection_size $clrn_collection]

if {$aclr_counter == 0 &&  $clrn_counter == 0 && $num_sync_count > 0} {
    set_max_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] 100
    set_min_delay  -to [get_registers ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain[[expr $num_sync_count-1]]] -100
}

if {$aclr_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|aclr]
}

if {$clrn_counter > 0} {
    set_false_path -to [get_pins -compatibility_mode -nocase ${hpath}alt_rst_sync_uq1|altera_reset_synchronizer_int_chain*|clrn]
}
 1
